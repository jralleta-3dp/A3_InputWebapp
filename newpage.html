<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Submit Data to Google Sheets</title>

  <!-- Google Identity Services -->
  <script src="https://accounts.google.com/gsi/client" async defer></script>

  <style>
    /* --- Dashboard-inspired global background and container --- */
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
      background: radial-gradient(ellipse at 60% 0%, #e6f4ea 0%, #f6f8fa 80%);
      color: #24292e;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 0;
      margin: 0;
      min-height: 100vh;
    }
    .container {
      background-color: #fff;
      border-radius: 16px;
      box-shadow:
        0 8px 32px rgba(0,0,0,0.13),
        0 1.5px 8px 0 rgba(44,162,78,0.08),
        0 0.5px 1.5px 0 rgba(33,136,56,0.10);
      padding: 32px 32px 24px 32px;
      max-width: 1200px; /* Increased width for horizontal layout */
      min-width: 1000px;
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 20px;
      border: 1.5px solid transparent;
      background-clip: padding-box;
      position: relative;
      z-index: 1;
    }
    .container::before {
      content: "";
      position: absolute;
      inset: 0;
      z-index: -1;
      border-radius: 18px;
      padding: 2px;
      background: linear-gradient(120deg, #2da44e 0%, #e1e4e8 100%);
      opacity: 0.13;
      pointer-events: none;
    }
    /* --- Section headers with green accent underline --- */
    .section-header {
      font-size: 18px;
      font-weight: bold;
      color: #24292e;
      margin-bottom: 8px;
      position: relative;
      padding-bottom: 6px;
      text-align: left;
      letter-spacing: 0.5px;
    }
    .section-header::after {
      content: "";
      display: block;
      margin: 8px 0 0 0;
      width: 48px;
      height: 3px;
      border-radius: 2px;
      background: linear-gradient(90deg, #2da44e 60%, #218838 100%);
      opacity: 0.7;
    }
    /* --- Card/box shadow for all major sections --- */
    .row-layout {
      display: flex;
      flex-direction: row;
      justify-content: flex-start;
      align-items: center;
      gap: 18px;
      width: 100%;
      box-sizing: border-box;
      background: none;
      border: none;
      box-shadow: none;
      padding: 0;
      margin-bottom: 0;
      max-width: 100%;
      min-width: 900px;
    }
    .label-box,
    .button-group-box {
      /* Ensure all row children stretch to same height for symmetry */
      align-items: center;
      height: 100%;
      display: flex;
      flex-direction: row;
      justify-content: center;
    }
    .dropdown-group-box,
    .checkbox-group-box {
      flex: 1 1 0;
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 20px;
      background-color: #f6f8fa;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.07);
      padding: 16px;
      box-sizing: border-box;
      min-width: 0;
      justify-content: flex-start;
    }
    
    .row-layout {
      background-color: #fff;
      border-radius: 10px;
      box-shadow:
        0 2px 8px rgba(44, 162, 78, 0.08),
        0 1.5px 6px 0 rgba(33,136,56,0.10);
      border: 1.5px solid #e1e4e8;
      padding: 18px 18px 14px 18px;
      gap: 20px;
      display: flex;
      flex-direction: row;
      justify-content: left;
      position: relative;
    }
    .second-row-layout{
      background-color: #fff;
      border-radius: 10px;
      box-shadow:
        0 2px 8px rgba(44, 162, 78, 0.08),
        0 1.5px 6px 0 rgba(33,136,56,0.10);
      border: 1.5px solid #e1e4e8;
      padding: 18px 18px 14px 18px;
      gap: 10px;
      display: flex;
      flex-direction: row;
      justify-content: left;
      position: relative;
    }

    .dropdown-group-box .dropdown-input {
      flex: 1 1 0;
      min-width: 180px;
      max-width: 250px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .checkbox-group-box .checkbox-label {
      flex: 1 1 0;
      min-width: 180px;
      max-width: 250px;
      display: flex;
      flex-direction: row;
      justify-content: center;
      gap: 30px;
    }

    .third-row-layout {
      background-color: #fff;
      border-radius: 10px;
      box-shadow:
        0 2px 8px rgba(44, 162, 78, 0.08),
        0 1.5px 6px 0 rgba(33,136,56,0.10);
      border: 1.5px solid #e1e4e8;
      padding: 18px 18px 14px 18px;
      gap: 10px;
      display: flex;
      flex-direction: column;
      position: relative;
    }
    .third-row-layout label {
      font-size: 1.2em;
      font-weight: bold;
      color: #24292e;
      margin-bottom: 4px;
      position: relative;
      padding-bottom: 6px;
    }
    .third-row-layout label::after {
      content: "";
      display: block;
      margin: 8px 0 0 0;
      width: 48px;
      height: 3px;
      border-radius: 2px;
      background: linear-gradient(90deg, #2da44e 60%, #218838 100%);
      opacity: 0.7;
    }

    .third-row-layout input[type="text"] {
      width: 95%;
      padding: 8px 12px;
      font-size: 14px;
      border: 1px solid #d0d7de;
      border-radius: 6px;
      background-color: #ffffff;
      color: #24292e;
      outline: none;
      transition: border-color 0.2s, box-shadow 0.2s;
      box-shadow: 0 1px 4px rgba(44, 162, 78, 0.04);
    }
    


    .bottom-section,
    .last-section {
      background-color: #fff;
      border-radius: 10px;
      box-shadow:
        0 2px 8px rgba(44, 162, 78, 0.08),
        0 1.5px 6px 0 rgba(33,136,56,0.10);
      border: 1.5px solid #e1e4e8;
      padding: 18px 18px 14px 18px;
      gap: 10px;
      display: flex;
      flex-direction: column;
      position: relative;
    }
    /* --- Label Box and Button Group --- */
    .label-box {
      display: flex;
      flex-direction: row;
      align-items: center;
      background-color: #f6f8fa;
      padding: 12px 18px;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(44, 162, 78, 0.07);
      gap: 10px;
      min-width: 50%;
      width: auto;
      max-width: 420px;
    }

    .editable-name {
      flex: 1 1 0;
      min-width: 180px;
      font-size: 1.3em !important;
      font-weight: bold;
      color: #24292e;
      border: none;
      background-color: transparent;
      outline: none;
      text-align: left;
      width: 100%;
      cursor: text;
      transition: color 0.2s, font-weight 0.2s;
      padding: 0 0 0 2px;
    }
    .editable-name:focus {
      border-bottom: 2px solid #0969da;
    }
    .entry-number {
      display: none;
    }
    #addRowButton {
      margin-left: 0;
      min-width: 38px;
      min-height: 38px;
      font-size: 1.3em;
      padding: 0 12px;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .row-layout .button {
      min-width: 110px;
      margin: 0 2px;
      font-size: 1em;
      padding: 10px 0;
    }
    .button-group-box {
      flex: 1 1 0;
      display: flex;
      flex-direction: column;
      gap: 16px;
      background-color: #ffffff;
      padding: 18px 12px;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(44, 162, 78, 0.07);
      box-sizing: border-box;
      min-width: 180px;
      max-width: 220px;
      justify-content: center;
      align-items: stretch;
    }
    .button-group-box .button {
      width: 100%;
      margin: 0;
      font-size: 1.08em;
      padding: 10px 0;
    }
    /* --- Buttons --- */
    .button, .green-button {
      padding: 8px 16px;
      font-size: 15px;
      font-weight: 700;
      background: linear-gradient(90deg, #2da44e 60%, #218838 100%);
      color: #fff;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.18s, transform 0.13s, box-shadow 0.18s;
      box-shadow: 0 2px 8px rgba(44, 162, 78, 0.08), 0 1.5px 6px 0 rgba(33,136,56,0.10);
      letter-spacing: 0.5px;
      outline: none;
      text-align: center;
      text-shadow: 0 1px 4px rgba(33,136,56,0.10);
      margin-left: 0;
    }
    .button:hover, .green-button:hover, .button:focus, .green-button:focus {
      background: linear-gradient(90deg, #218838 60%, #2da44e 100%);
      transform: translateY(-2px) scale(1.035);
      box-shadow: 0 6px 18px rgba(44, 162, 78, 0.13), 0 2px 8px rgba(33,136,56,0.12), 0 0 12px 2px #2da44e33;
    }
    .button:active, .green-button:active {
      transform: scale(0.98);
    }
    .button.secondary {
      background-color: #f6f8fa;
      color: #24292e;
      border: 1px solid #d0d7de;
    }
    .button.secondary:hover {
      background-color: #eaeef2;
    }
    /* --- Inputs and Selects --- */
    input[type="text"], select {
      width: 90%;
      padding: 8px 12px;
      font-size: 14px;
      border: 1px solid #d0d7de;
      border-radius: 6px;
      background-color: #ffffff;
      color: #24292e;
      outline: none;
      transition: border-color 0.2s, box-shadow 0.2s;
      box-shadow: 0 1px 4px rgba(44, 162, 78, 0.04);
      margin-bottom: 14px; /* Add space below each input */
      margin-top: 4px;     /* Add a little space above each input */
    }
    /* Remove bottom margin for last input in a section */
    .third-row-layout input[type="text"]:last-child,
    .bottom-section input[type="text"]:last-child,
    .bottom-section select:last-child,
    .last-section input[type="text"]:last-child {
      margin-bottom: 0;
    }
    /* Add spacing between label/input pairs in grid */
    .grid-3col > * {
      margin-bottom: 10px;
    }
    /* Add padding inside section containers for input spacing */
    .third-row-layout,
    .bottom-section,
    .last-section {
      padding-top: 22px;
      padding-bottom: 22px;
      padding-left: 22px;
      padding-right: 22px;
    }
    /* --- Checkboxes --- */
    .checkbox-label {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 1.2em;
      
      color: #24292e;
    }
    .checkbox-label input {
      width: 28px;
      height: 28px;
      cursor: pointer;
    }
    /* --- Editable Name --- */
    .editable-name {
      font-size: 1.4em !important;
      font-weight: bold;
      color: #24292e;
      border: none;
      background-color: transparent;
      outline: none;
      text-align: center;
      width: 200%;
      cursor: text;
      transition: color 0.2s, font-weight 0.2s;
    }
    .editable-name:focus {
      border-bottom: 2px solid #0969da;
    }
    .editable-name.saved {
      font-weight: bold;
      color: #0969da;
    }
    /* --- Entry Number --- */
    .entry-number {
      visibility: hidden;
      font-size: 0.4em;
      color: #57606a;
      margin-top: 4px;
    }
    /* --- Grid layout for bottom section --- */
    .grid-3col {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 16px;
      align-items: start;
    }
    /* --- Footer --- */
    .footer {
      text-align: center;
      font-size: 13px;
      color: #57606a;
      margin-top: 18px;
      padding: 10px 0 0 0;
      border-top: 1px solid #d0d7de;
      width: 100%;
      letter-spacing: 0.5px;
      box-shadow: 0 -2px 8px rgba(44,162,78,0.04);
    }

    .row-layout .button-box {
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: center;
      gap: 10px;
    }

    .row-layout .time-box {
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: center;
      gap: 10px;
    }
    .row-layout .button-time-group {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      gap: 10px;
    }
    /* --- Responsive for mobile --- */
    @media (max-width: 900px) {
      .container {
        padding: 18px 2vw 12px 2vw;
        max-width: 99vw;
      }
      .row-layout, .second-row-layout, .third-row-layout, .bottom-section, .last-section {
        padding: 10px 4vw 8px 4vw;
      }
      .label-box, .button-group-box {
        padding: 10px;
      }
    }
    @media (max-width: 600px) {
      .container {
        padding: 8px 2vw 8px 2vw;
        max-width: 99vw;
      }
      .dashboard-title, .section-header {
        font-size: 1.1em;
      }
      .button, .green-button {
        font-size: 1em;
        padding: 10px 0;
      }
    }
    /* Dark mode styles */
    body.dark-mode {
      background: #181c1f;
      color: #e6e6e6;
    }
    .container.dark-mode {
      background-color: #23272b !important;
      border-color: #333c43;
      box-shadow: 0 8px 32px rgba(0,0,0,0.33);
      color: #e6e6e6;
    }
    .section-header.dark-mode {
      color: #e6e6e6;
      text-shadow: none;
    }
    .label-box.dark-mode,
    .button-group-box.dark-mode,
    .dropdown-group-box.dark-mode,
    .checkbox-group-box.dark-mode,
    .third-row-layout.dark-mode,
    .bottom-section.dark-mode,
    .last-section.dark-mode,
    .row-layout.dark-mode,
    .second-row-layout.dark-mode {
      background-color: #23272b !important;
      border-color: #333c43;
      color: #e6e6e6;
    }
    .label-box.dark-mode input,
    .button-group-box.dark-mode input,
    .dropdown-group-box.dark-mode select,
    .third-row-layout.dark-mode input,
    .bottom-section.dark-mode input,
    .bottom-section.dark-mode select,
    .last-section.dark-mode input,
    .row-layout.dark-mode input,
    .second-row-layout.dark-mode input,
    .second-row-layout.dark-mode select {
      background-color: #23272b !important;
      color: #e6e6e6 !important;
      border-color: #333c43 !important;
    }
    .checkbox-label.dark-mode {
      color: #e6e6e6 !important;
    }
    .editable-name.dark-mode {
      color: #e6e6e6 !important;
      background-color: transparent !important;
    }
    .button.dark-mode, .green-button.dark-mode {
      background: linear-gradient(90deg, #218838 60%, #2da44e 100%);
      color: #fff !important;
      box-shadow: 0 2px 8px rgba(44, 162, 78, 0.18), 0 1.5px 6px 0 rgba(33,136,56,0.18);
    }
    .button.dark-mode:hover, .green-button.dark-mode:hover, .button.dark-mode:focus, .green-button.dark-mode:focus {
      background: linear-gradient(90deg, #2da44e 60%, #218838 100%);
    }
    .footer.dark-mode {
      color: #b6bfc7 !important;
      border-top: 1px solid #333c43;
      box-shadow: 0 -2px 8px rgba(44,162,78,0.10);
      background-color: #23272b !important;
    }
    input[type="text"].dark-mode, select.dark-mode {
      background-color: #23272b !important;
      color: #e6e6e6 !important;
      border-color: #333c43 !important;
    }
    .third-row-layout label.dark-mode,
    .bottom-section label.dark-mode,
    .last-section label.dark-mode,
    .dropdown-group-box label.dark-mode,
    .checkbox-label.dark-mode {
      color: #e6e6e6 !important;
    }
    .section-header.dark-mode::after {
      background: linear-gradient(90deg, #2da44e 60%, #218838 100%);
      opacity: 0.7;
    }
    .row-layout.dark-mode,
    .second-row-layout.dark-mode {
      background-color: #23272b !important;
      color: #e6e6e6 !important;
    }
    .row-layout.dark-mode .button,
    .row-layout.dark-mode .green-button {
      color: #fff !important;
    }
    .row-layout.dark-mode .editable-name {
      color: #e6e6e6 !important;
    }
    .row-layout.dark-mode .entry-number {
      color: #b6bfc7 !important;
    }
    .row-layout.dark-mode .button-time-group,
    .row-layout.dark-mode .button-box,
    .row-layout.dark-mode .time-box {
      color: #e6e6e6 !important;
    }
    #startTimeDisplay.dark-mode, #endTimeDisplay.dark-mode {
      color: #b6bfc7 !important;
    }
    /* --- Toggle Switch for Dark Mode --- */
    .dark-mode-switch {
      width: 38px;
      height: 20px;
      position: relative;
      display: inline-block;
    }
    .dark-mode-switch input {
      opacity: 0;
      width: 0;
      height: 0;
      position: absolute;
    }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0; left: 0; right: 0; bottom: 0;
      background-color: #ccc;
      border-radius: 20px;
      transition: .3s;
      outline: none;
      display: block;
    }
    .slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 2px;
      bottom: 2px;
      background-color: #fff;
      border-radius: 50%;
      transition: .3s;
    }
    .slider-checked {
      background-color: #218838 !important;
    }
    .slider-checked:before {
      transform: translateX(18px);
    }
    .slider:focus {
      box-shadow: 0 0 2px #218838;
    }
  </style>
</head>
<body>
    <div class="container">
        <div style="display: flex; align-items: center; justify-content: space-between; width: 100%; position: relative;">
            <div class="section-header" style="margin-bottom: 0;">Sampling</div>
            <div class="dark-mode-toggle" style="position: static; margin-left: 16px;">
                <span>ðŸŒ™</span>
                <label class="dark-mode-switch">
                    <input type="checkbox" id="darkModeCheckbox" style="display:none;">
                    <span class="slider" tabindex="0" id="darkModeSlider"></span>
                </label>
            </div>
        </div>
        <!-- Button row, this should be a back and next arrow -->
        <div class="row-layout">
          <button id="backButton" class="button">&#8592; Back</button>
          <!-- Label Box -->

          <div class="label-box">
            <input id="editableName" class="editable-name" type="text" placeholder="Enter Sample Name...." />
            <span id="entryNumber" class="entry-number"></span>
            <button id="addRowButton" class="button green-button">+</button>
          </div>
          <div class="button-time-group">
            <div class="button-box">
              <button id="startTimeButton" class="button">Start Time</button>
              <button id="endTimeButton" class="button">End Time</button>
            </div>
            <div class="time-box">
              <div id="startTimeDisplay" style="font-size:0.9em;color:#57606a;margin-bottom:4px;"></div>
              <div id="endTimeDisplay" style="font-size:0.9em;color:#57606a;margin-bottom:4px;"></div>
            </div>
          </div>
          
          <button id="nextButton" class="button">Next &#8594;</button>
          
        </div>

        <div class="second-row-layout">
          <!-- Dropdown Group Box -->
          <div class="dropdown-group-box">
            <label class="dropdown-input">
              <label for ="EVAnumber">EVA #:</label>
              <select id="EVAnumber" name="EVA Number:">
                <option value="" disabled selected>EVA...</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
              </select>
            </label>
            <label class="dropdown-input">
              <label for="Station">Station:</label>
              <select id="Station" name="Station:">
                <option value="" disabled selected>Station...</option>
                <option value="Traverse">Traverse</option>
                <option value="Station 1">Station 1</option>
                <option value="Station 2">Station 2</option>
                <option value="Station 3">Station 3</option>
                <option value="Station 4">Station 4</option>
              </select>
            </label>
            
          </div>
        
          <!-- Checkbox Group Box -->
          <div class="checkbox-group-box">
            <label class="checkbox-label">
              <input type="checkbox" id="Planned" name="Planned" value="True">
              Planned
            </label>
            <label class="checkbox-label">
              <input type="checkbox" id="Unplanned" name="Unplanned" value="True">
              Unplanned
            </label>
          </div>
        </div>

        <div class="third-row-layout">
            <label for="CrewDescription">Crew Description:</label><br>
            <input type="text" id="CrewDescription" name="Crew Description">
        </div>
        <div class="bottom-section">
          <div class="section-header">Sample Characteristics</div>
          <div class="grid-3col">
            <!-- Row 1: Labels -->
            <label for="SampleType">Sample Type:</label>
            <label for="Units">Unit:</label>
            <label for="Condition">Condition:</label>
        
            <!-- Row 2: Inputs -->
            <select id="SampleType" name="Sample Type:">
              <option value=""></option>
              <option value="Rake">Rake</option>
              <option value="Scoop">Scoop</option>
              <option value="Chip">Chip</option>
              <option value="Float">Float</option>
              <option value="Skim">Skim</option>
              <option value="Single Drive Tube">Single Drive Tube</option>
              <option value="Double Drive Tube">Double Drive Tube</option>
            </select>
        
            <input type="text" id="Units" name="Unit:">
        
            <select id="Condition" name="Condition:">
              <option value=""></option>
              <option value="Illuminated">Illuminated</option>
              <option value="Shadowed">Shadowed</option>
              <option value="Undisturbed">Undisturbed</option>
              <option value="Disturbed">Disturbed</option>
              <option value="Cold">Cold</option>
            </select>
        
            <!-- Row 3: Labels -->
            <label for="MassEstimate">Mass Estimate:</label>
            <label for="VolumeEstimate">Volume Estimate:</label>
            <label for="ContainerNumber">Container Number(s):</label>
        
            <!-- Row 4: Inputs -->
            <input type="text" id="MassEstimate" name="Mass Estimate:">
            <input type="text" id="VolumeEstimate" name="Volume Estimate:">
            <input type="text" id="ContainerNumber" name="Container Number(s)">
          </div>
        </div>
        <div class="last-section">
          <div class="section-header">Collection Details</div>
          <div class="last-section-layout">
            <label for="ContaminationNotes">Contamination Notes:</label>
            <input type="text" id="ContaminationNotes" name="Contamination Notes">
          </div>
          <div class="last-section-layout">
            <label for="SamplingTools">Sampling Tool(s):</label>
            <input type="text" id="SamplingTools" name="Sampling Tool(s)">
          </div>
        </div>
        <div class="footer" id="footerCount">1</div>
        
    </div>

    <script>
      // Dark mode logic
      function setDarkMode(enabled) {
        document.body.classList.toggle('dark-mode', enabled);
        document.querySelectorAll('.container').forEach(el => el.classList.toggle('dark-mode', enabled));
        document.querySelectorAll('.section-header').forEach(el => el.classList.toggle('dark-mode', enabled));
        document.querySelectorAll('.label-box, .button-group-box, .dropdown-group-box, .checkbox-group-box, .third-row-layout, .bottom-section, .last-section, .row-layout, .second-row-layout').forEach(el => el.classList.toggle('dark-mode', enabled));
        document.querySelectorAll('.button, .green-button').forEach(el => el.classList.toggle('dark-mode', enabled));
        document.querySelectorAll('.footer').forEach(el => el.classList.toggle('dark-mode', enabled));
        document.querySelectorAll('input[type="text"], select').forEach(el => el.classList.toggle('dark-mode', enabled));
        document.querySelectorAll('label').forEach(el => el.classList.toggle('dark-mode', enabled));
        document.querySelectorAll('.editable-name').forEach(el => el.classList.toggle('dark-mode', enabled));
        document.querySelectorAll('.checkbox-label').forEach(el => el.classList.toggle('dark-mode', enabled));
        document.querySelectorAll('#startTimeDisplay, #endTimeDisplay').forEach(el => el.classList.toggle('dark-mode', enabled));
        // Sync slider UI
        const slider = document.getElementById('darkModeSlider');
        if (slider) {
          if (enabled) slider.classList.add('slider-checked');
          else slider.classList.remove('slider-checked');
        }
      }
      document.addEventListener('DOMContentLoaded', function() {
        const darkMode = localStorage.getItem('darkMode') === 'true';
        const darkModeCheckbox = document.getElementById('darkModeCheckbox');
        const darkModeSlider = document.getElementById('darkModeSlider');
        if (darkModeCheckbox) {
          darkModeCheckbox.checked = darkMode;
          setDarkMode(darkMode);
        }
        if (darkModeSlider) {
          // Set initial slider state
          if (darkMode) darkModeSlider.classList.add('slider-checked');
          else darkModeSlider.classList.remove('slider-checked');
          // Click/tap toggles dark mode
          darkModeSlider.addEventListener('click', function() {
            const enabled = !darkModeCheckbox.checked;
            darkModeCheckbox.checked = enabled;
            setDarkMode(enabled);
            localStorage.setItem('darkMode', enabled);
          });
          // Keyboard accessibility
          darkModeSlider.addEventListener('keydown', function(e) {
            if (e.key === ' ' || e.key === 'Enter') {
              e.preventDefault();
              darkModeSlider.click();
            }
          });
        }
      });
      //Function to write Start Time to Sheet with safeApiCall checks
      function writeStartTime(currentCount) {
        return safeApiCall(() => {
            const nowGMT = new Date().toISOString();
            const targetRow = currentCount + 1;
            const rangeToCheck = `Sheet1!B${targetRow}`;

            return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToCheck}?majorDimension=ROWS`, {
                method: "GET",
                headers: {
                    "Authorization": `Bearer ${accessToken}`,
                }
            })
                .then(res => {
                    if (!res.ok) throw res;
                    return res.json();
                })
                .then(data => {
                    const existingRow = data.values?.[0] || [];
                    let rangeToWrite;
                    let values;

                    if (existingRow.length === 0 || existingRow[0] === undefined || existingRow[0] === "") { // Check if column B is empty
                        rangeToWrite = `Sheet1!B${targetRow}:C${targetRow}`; // Write to columns B and C
                        values = [[nowGMT, nowGMT]]; // Write the timestamp to both columns
                    } else {
                        rangeToWrite = `Sheet1!C${targetRow}`; // Write to column C only
                        values = [[nowGMT]]; // Write the timestamp to column C
                    }

                    return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToWrite}?valueInputOption=RAW`, {
                        method: "PUT",
                        headers: {
                            "Authorization": `Bearer ${accessToken}`,
                            "Content-Type": "application/json"
                        },
                        body: JSON.stringify({ values })
                    });
                });
        });
      }
      //Function to write End Time to Sheet with safeApiCall checks
      function writeEndTime(currentCount) {
        return safeApiCall(() => {
            const nowGMT = new Date().toISOString();
            const targetRow = currentCount + 1;
            const rangeToCheck = `Sheet1!B${targetRow}`; // Check column B

            return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToCheck}?majorDimension=ROWS`, {
                method: "GET",
                headers: {
                    "Authorization": `Bearer ${accessToken}`,
                }
            })
                .then(res => {
                    if (!res.ok) throw res;
                    return res.json();
                })
                .then(data => {
                    const existingRow = data.values?.[0] || [];
                    let rangeToWrite;
                    let values;

                    if (existingRow.length === 0 || existingRow[0] === undefined || existingRow[0] === "") { // Check if column B is empty
                        rangeToWrite = `Sheet1!B${targetRow}:D${targetRow}`; // Write to columns B and D
                        values = [[nowGMT, existingRow[2] || "", nowGMT]]; // Write the timestamp to B and D, preserve C
                    } else {
                        rangeToWrite = `Sheet1!D${targetRow}`; // Write to column D only
                        values = [[nowGMT]]; // Write the timestamp to column D
                    }

                    return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToWrite}?valueInputOption=RAW`, {
                        method: "PUT",
                        headers: {
                            "Authorization": `Bearer ${accessToken}`,
                            "Content-Type": "application/json"
                        },
                        body: JSON.stringify({ values })
                    });
                });
        });
      }
      //function for writing Crew Description to Sheet with safeApiCall checks
      function writeCrewDescriptionToSheet(crewDescription, currentCount) {
        return safeApiCall(() => {
            const targetRow = currentCount + 1;
            const nowGMT = new Date().toISOString();
            const rangeToCheck = `Sheet1!B${targetRow}`; // Check column B

            return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToCheck}?majorDimension=ROWS`, {
                method: "GET",
                headers: {
                    "Authorization": `Bearer ${accessToken}`,
                }
            })
                .then(res => {
                    if (!res.ok) throw res;
                    return res.json();
                })
                .then(data => {
                    const existingRow = data.values?.[0] || [];
                    let rangeToWrite;
                    let values;

                    if (existingRow.length === 0 || existingRow[0] === undefined || existingRow[0] === "") { // Check if column B is empty
                        rangeToWrite = `Sheet1!B${targetRow}:E${targetRow}`; // Write to columns B and E
                        values = [[nowGMT, existingRow[2] || "", existingRow[3] || "", crewDescription]]; // Write timestamp to B, preserve C and D, and description to E
                    } else {
                        rangeToWrite = `Sheet1!E${targetRow}`; // Write to column E only
                        values = [[crewDescription]]; // Write the description to column E
                    }

                    return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToWrite}?valueInputOption=RAW`, {
                        method: "PUT",
                        headers: {
                            "Authorization": `Bearer ${accessToken}`,
                            "Content-Type": "application/json"
                        },
                        body: JSON.stringify({ values })
                    });
                });
        });
      }
      // function for writing sampling tools to sheet with safeApiCall checks
      function writeToolsToSheet(selectedTools, currentCount) {
        return safeApiCall(() => {
            const targetRow = currentCount + 1;
            const nowGMT = new Date().toISOString();
            const rangeToCheck = `Sheet1!B${targetRow}`; // Check column B

            return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToCheck}?majorDimension=ROWS`, {
                method: "GET",
                headers: {
                    "Authorization": `Bearer ${accessToken}`,
                }
            })
                .then(res => {
                    if (!res.ok) throw res;
                    return res.json();
                })
                .then(data => {
                    const existingRow = data.values?.[0] || [];
                    let rangeToWrite;
                    let values;

                    if (existingRow.length === 0 || existingRow[0] === undefined || existingRow[0] === "") { // Check if column B is empty
                        rangeToWrite = `Sheet1!B${targetRow}:M${targetRow}`; // Write to columns B and M
                        values = [[nowGMT, existingRow[2] || "", existingRow[3] || "", existingRow[4] || "", existingRow[5] || "", existingRow[6] || "", existingRow[7] || "", existingRow[8] || "", existingRow[9] || "", existingRow[10] || "", existingRow[11] || "", existingRow[12] || "", selectedTools]]; // Write timestamp to B, preserve C-L, and tools to M
                    } else {
                        rangeToWrite = `Sheet1!M${targetRow}`; // Write to column M only
                        values = [[selectedTools]]; // Write the tools to column M
                    }

                    return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToWrite}?valueInputOption=RAW`, {
                        method: "PUT",
                        headers: {
                            "Authorization": `Bearer ${accessToken}`,
                            "Content-Type": "application/json"
                        },
                        body: JSON.stringify({ values })
                    });
                });
        });
      }
      // function for writing Sample Type to sheet with safeApiCall checks
      function writeSampleTypeToSheet(selectedSampleType, currentCount) {
        return safeApiCall(() => {
            const targetRow = currentCount + 1;
            const nowGMT = new Date().toISOString();
            const rangeToCheck = `Sheet1!B${targetRow}`;

            return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToCheck}?majorDimension=ROWS`, {
                method: "GET",
                headers: {
                    "Authorization": `Bearer ${accessToken}`,
                }
            })
                .then(res => {
                    if (!res.ok) throw res;
                    return res.json();
                })
                .then(data => {
                    const existingRow = data.values?.[0] || [];
                    let rangeToWrite;
                    let values;

                    if (existingRow.length === 0 || existingRow[0] === undefined || existingRow[0] === "") { // Check if column B is empty
                        rangeToWrite = `Sheet1!B${targetRow}:F${targetRow}`; // Write to columns B and F
                        values = [[nowGMT, existingRow[2] || "", existingRow[3] || "", existingRow[4] || "", existingRow[5] || "", selectedSampleType]]; // Write timestamp to B, preserve C-E, and sample type to F
                    } else {
                        rangeToWrite = `Sheet1!F${targetRow}`; // Write to column F only
                        values = [[selectedSampleType]]; // Write the sample type to column F
                    }

                    return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToWrite}?valueInputOption=RAW`, {
                        method: "PUT",
                        headers: {
                            "Authorization": `Bearer ${accessToken}`,
                            "Content-Type": "application/json"
                        },
                        body: JSON.stringify({ values })
                    });
                });
        });
      }
      // Add: function for writing Station to sheet (column P, index 15)
      function writeStationToSheet(selectedStation, currentCount) {
        return safeApiCall(() => {
          const targetRow = currentCount + 1;
          const nowGMT = new Date().toISOString();
          const rangeToCheck = `Sheet1!B${targetRow}`;
          return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToCheck}?majorDimension=ROWS`, {
            method: "GET",
            headers: {
              "Authorization": `Bearer ${accessToken}`,
            }
          })
          .then(res => {
            if (!res.ok) throw res;
            return res.json();
          })
          .then(data => {
            const existingRow = data.values?.[0] || [];
            let rangeToWrite;
            let values;
            if (existingRow.length === 0 || existingRow[0] === undefined || existingRow[0] === "") {
              // Write to columns B through P (columns 2-16)
              rangeToWrite = `Sheet1!B${targetRow}:P${targetRow}`;
              // Fill up to column O (index 14) with existing or empty, then column P (index 15) with selectedStation
              values = [[
                nowGMT, // B
                existingRow[2] || "", // C
                existingRow[3] || "", // D
                existingRow[4] || "", // E
                existingRow[5] || "", // F
                existingRow[6] || "", // G
                existingRow[7] || "", // H
                existingRow[8] || "", // I
                existingRow[9] || "", // J
                existingRow[10] || "", // K
                existingRow[11] || "", // L
                existingRow[12] || "", // M
                existingRow[13] || "", // N
                existingRow[14] || "", // O (EVA)
                selectedStation // P (Station)
              ]];
            } else {
              rangeToWrite = `Sheet1!P${targetRow}`;
              values = [[selectedStation]];
            }
            return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToWrite}?valueInputOption=RAW`, {
              method: "PUT",
              headers: {
                "Authorization": `Bearer ${accessToken}`,
                "Content-Type": "application/json"
              },
              body: JSON.stringify({ values })
            });
          });
        });
      }
      // Add: function for writing EVA to sheet (column O, index 14)
      function writeEVAToSheet(selectedEVA, currentCount) {
        return safeApiCall(() => {
          const targetRow = currentCount + 1;
          const nowGMT = new Date().toISOString();
          const rangeToCheck = `Sheet1!B${targetRow}`;
          return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToCheck}?majorDimension=ROWS`, {
            method: "GET",
            headers: {
              "Authorization": `Bearer ${accessToken}`,
            }
          })
          .then(res => {
            if (!res.ok) throw res;
            return res.json();
          })
          .then(data => {
            const existingRow = data.values?.[0] || [];
            let rangeToWrite;
            let values;
            if (existingRow.length === 0 || existingRow[0] === undefined || existingRow[0] === "") {
              // Write to columns B through O (columns 2-15)
              rangeToWrite = `Sheet1!B${targetRow}:O${targetRow}`;
              // Fill up to column N (index 13) with existing or empty, then column O (index 14) with selectedEVA
              values = [[
                nowGMT, // B
                existingRow[2] || "", // C
                existingRow[3] || "", // D
                existingRow[4] || "", // E
                existingRow[5] || "", // F
                existingRow[6] || "", // G
                existingRow[7] || "", // H
                existingRow[8] || "", // I
                existingRow[9] || "", // J
                existingRow[10] || "", // K
                existingRow[11] || "", // L
                existingRow[12] || "", // M
                existingRow[13] || "", // N
                selectedEVA // O (EVA)
              ]];
            } else {
              rangeToWrite = `Sheet1!O${targetRow}`;
              values = [[selectedEVA]];
            }
            return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToWrite}?valueInputOption=RAW`, {
              method: "PUT",
              headers: {
                "Authorization": `Bearer ${accessToken}`,
                "Content-Type": "application/json"
              },
              body: JSON.stringify({ values })
            });
          });
        });
      }
      //function for integfrating timeout on page load
      function fetchWithTimeoutAndPrompt(rowIndex, timeoutMs = 10000) {
        let didRespond = false;

        // Start the fetch
        fetchRowData(rowIndex).then(data => {
          didRespond = true;
          fillInputsWithRowData(data);
        }).catch(err => {
          didRespond = true;
          console.error("Fetch error:", err);
          // Optionally show an error to the user here
        });

        // Set up the timeout to prompt sign-in if no response
        setTimeout(() => {
          if (!didRespond) {
            alert("Session expired or not signed in. Please sign in with Google to continue.");
            if (typeof tokenClient !== "undefined" && tokenClient) {
              tokenClient.requestAccessToken({ prompt: 'consent' });
            } else {
              window.location.href = 'index.html'; // Fallback: redirect to login
            }
          }
        }, timeoutMs);
      }
      // function for writing Contamination Notes:
      function writeContaminationToSheet(selectedContamination, currentCount) {
        return safeApiCall(() => {
            const targetRow = currentCount + 1;
            const nowGMT = new Date().toISOString();
            const rangeToCheck = `Sheet1!B${targetRow}`; // Check column B

            return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToCheck}?majorDimension=ROWS`, {
                method: "GET",
                headers: {
                    "Authorization": `Bearer ${accessToken}`,
                }
            })
            .then(res => {
                if (!res.ok) throw res;
                return res.json();
            })
            .then(data => {
                const existingRow = data.values?.[0] || [];
                let rangeToWrite;
                let values;

                if (existingRow.length === 0 || existingRow[0] === undefined || existingRow[0] === "") { // Check if column B is empty
                    rangeToWrite = `Sheet1!B${targetRow}:L${targetRow}`; // Write to columns B and L
                    values = [[nowGMT, existingRow[2] || "", existingRow[3] || "", existingRow[4] || "", existingRow[5] || "", existingRow[6] || "", existingRow[7] || "", existingRow[8] || "", existingRow[9] || "", existingRow[10] || "", existingRow[11] || "", selectedContamination]]; // Write timestamp to B, preserve C-K, and contamination to L
                } else {
                    rangeToWrite = `Sheet1!L${targetRow}`; // Write to column L only
                    values = [[selectedContamination]]; // Write the contamination to column L
                }

                return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToWrite}?valueInputOption=RAW`, {
                    method: "PUT",
                    headers: {
                        "Authorization": `Bearer ${accessToken}`,
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({ values })
                });
            })
            .catch(error => {
                console.error("Failed to write Contamination Notes:", error);
            });
        });
      }
      //function for writing Container Number(s) to sheet
      function writeContainerToSheet(selectedContainer, currentCount) {
        return safeApiCall(() => {
            const targetRow = currentCount + 1;
            const nowGMT = new Date().toISOString();
            const rangeToCheck = `Sheet1!B${targetRow}`; // Check column B

            return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToCheck}?majorDimension=ROWS`, {
                method: "GET",
                headers: {
                    "Authorization": `Bearer ${accessToken}`,
                }
            })
            .then(res => {
                if (!res.ok) throw res;
                return res.json();
            })
            .then(data => {
                const existingRow = data.values?.[0] || [];
                let rangeToWrite;
                let values;

                if (existingRow.length === 0 || existingRow[0] === undefined || existingRow[0] === "") { // Check if column B is empty
                    rangeToWrite = `Sheet1!B${targetRow}:K${targetRow}`; // Write to columns B and K
                    values = [[nowGMT, existingRow[2] || "", existingRow[3] || "", existingRow[4] || "", existingRow[5] || "", existingRow[6] || "", existingRow[7] || "", existingRow[8] || "", existingRow[9] || "", existingRow[10] || "", selectedContainer]]; // Write timestamp to B, preserve C-J, and container to K
                } else {
                    rangeToWrite = `Sheet1!K${targetRow}`; // Write to column K only
                    values = [[selectedContainer]]; // Write the container to column K
                }

                return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToWrite}?valueInputOption=RAW`, {
                    method: "PUT",
                    headers: {
                        "Authorization": `Bearer ${accessToken}`,
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({ values })
                });
            })
            .catch(error => {
                console.error("Failed to write Container Number(s):", error);
            });
        });
      }
      //function for writing Volume Estimate
      function writeVolumeToSheet(selectedVolume, currentCount) {
        return safeApiCall(() => {
          const targetRow = currentCount + 1;
          const nowGMT = new Date().toISOString();
          const rangeToCheck = `Sheet1!B${targetRow}`;

          return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToCheck}?majorDimension=ROWS`, {
                method: "GET",
                headers: {
                    "Authorization": `Bearer ${accessToken}`,
                }
            })
            .then(res => {
                if (!res.ok) throw res;
                return res.json();
            })
            .then(data => {
                const existingRow = data.values?.[0] || [];
                let rangeToWrite;
                let values;

                if (existingRow.length === 0 || existingRow[0] === undefined || existingRow[0] === "") { // Check if column B is empty
                    rangeToWrite = `Sheet1!B${targetRow}:J${targetRow}`; // Write to columns B and J
                    values = [[nowGMT, existingRow[2] || "", existingRow[3] || "", existingRow[4] || "", existingRow[5] || "", existingRow[6] || "", existingRow[7] || "", selectedVolume]]; // Write timestamp to B, preserve C-I, and volume to J
                } else {
                    rangeToWrite = `Sheet1!J${targetRow}`; // Write to column J only
                    values = [[selectedVolume]]; // Write the volume to column J
                }

                return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToWrite}?valueInputOption=RAW`, {
                    method: "PUT",
                    headers: {
                        "Authorization": `Bearer ${accessToken}`,
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({ values })
                });
            })
            .catch(error => {
                console.error("Failed to write Volume Estimate:", error);
            });
        });
      };

      // function for writing Mass Estimate
      function writeMassToSheet(selectedMass, currentCount) {
        return safeApiCall(() => {
          const targetRow = currentCount + 1;
          const nowGMT = new Date().toISOString();
          const rangeToCheck = `Sheet1!B${targetRow}`;

          return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToCheck}?majorDimension=ROWS`, {
                method: "GET",
                headers: {
                    "Authorization": `Bearer ${accessToken}`,
                }
            })
            .then(res => {
                if (!res.ok) throw res;
                return res.json();
            })
            .then(data => {
                const existingRow = data.values?.[0] || [];
                let rangeToWrite;
                let values;

                if (existingRow.length === 0 || existingRow[0] === undefined || existingRow[0] === "") { // Check if column B is empty
                    rangeToWrite = `Sheet1!B${targetRow}:I${targetRow}`; // Write to columns B and I
                    values = [[nowGMT, existingRow[2] || "", existingRow[3] || "", existingRow[4] || "", existingRow[5] || "", existingRow[6] || "", existingRow[7] || "", existingRow[8] || "", selectedMass]]; // Write timestamp to B, preserve C-H, and mass to I
                } else {
                    rangeToWrite = `Sheet1!I${targetRow}`; // Write to column I only
                    values = [[selectedMass]]; // Write the mass to column I
                }

                return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToWrite}?valueInputOption=RAW`, {
                    method: "PUT",
                    headers: {
                        "Authorization": `Bearer ${accessToken}`,
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({ values })
                });
            })
            .catch(error => {
                console.error("Failed to write Mass Estimate:", error);
            });
        });
      };

      //function for writing Condition
      function writeConditionToSheet(selectedCondition, currentCount) {
        return safeApiCall(() => {
          const targetRow = currentCount + 1;
          const nowGMT = new Date().toISOString();
          const rangeToCheck = `Sheet1!B${targetRow}`;

          return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToCheck}?majorDimension=ROWS`, {
                method: "GET",
                headers: {
                    "Authorization": `Bearer ${accessToken}`,
                }
            })
            .then(res => {
                if (!res.ok) throw res;
                return res.json();
            })
            .then(data => {
                const existingRow = data.values?.[0] || [];
                let rangeToWrite;
                let values;

                if (existingRow.length === 0 || existingRow[0] === undefined || existingRow[0] === "") { // Check if column B is empty
                    rangeToWrite = `Sheet1!B${targetRow}:H${targetRow}`; // Write to columns B and H
                    values = [[nowGMT, existingRow[2] || "", existingRow[3] || "", existingRow[4] || "", existingRow[5] || "", existingRow[6] || "", existingRow[7] || "", selectedCondition]]; // Write timestamp to B, preserve C-G, and condition to H
                } else {
                    rangeToWrite = `Sheet1!H${targetRow}`; // Write to column H only
                    values = [[selectedCondition]]; // Write the condition to column H
                }

                return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToWrite}?valueInputOption=RAW`, {
                    method: "PUT",
                    headers: {
                        "Authorization": `Bearer ${accessToken}`,
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({ values })
                });
            })
            .catch(error => {
                console.error("Failed to write Condition:", error);
            });
        });
      };

      //function for writing checkbox entry
      function writeCheckboxToSheet(labelText, currentCount) {
        return safeApiCall(() => {
            const targetRow = currentCount + 1;
            const nowGMT = new Date().toISOString();
            const rangeToCheck = `Sheet1!B${targetRow}`;

            return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToCheck}?majorDimension=ROWS`, {
                method: "GET",
                headers: {
                    "Authorization": `Bearer ${accessToken}`,
                }
            })
            .then(res => {
                if (!res.ok) throw res;
                return res.json();
            })
            .then(data => {
                const existingRow = data.values?.[0] || [];
                let rangeToWrite;
                let values;

                if (existingRow.length === 0 || existingRow[0] === undefined || existingRow[0] === "") { // Check if column B is empty
                    rangeToWrite = `Sheet1!B${targetRow}:N${targetRow}`; // Write to columns B and N
                    values = [[nowGMT, existingRow[2] || "", existingRow[3] || "", existingRow[4] || "", existingRow[5] || "", existingRow[6] || "", existingRow[7] || "", existingRow[8] || "", existingRow[9] || "", existingRow[10] || "", existingRow[11] || "", existingRow[12] || "", labelText]]; // Write timestamp to B, preserve C-M, and checkbox to N
                } else {
                    rangeToWrite = `Sheet1!N${targetRow}`; // Write to column N only
                    values = [[labelText]]; // Write the checkbox to column N
                }

                return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToWrite}?valueInputOption=RAW`, {
                    method: "PUT",
                    headers: {
                        "Authorization": `Bearer ${accessToken}`,
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({ values })
                });
            })
            .catch(error => {
                console.error("Failed to write Checkbox:", error);
            });
        });
      }

      //function for writing units to sheet
      function writeUnitsToSheet(selectedUnits, currentCount) {
        return safeApiCall(() => {
          const targetRow = currentCount + 1;
          const nowGMT = new Date().toISOString();
          const rangeToCheck = `Sheet1!B${targetRow}`;

          return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToCheck}?majorDimension=ROWS`, {
                method: "GET",
                headers: {
                    "Authorization": `Bearer ${accessToken}`,
                }
            })
            .then(res => {
                if (!res.ok) throw res;
                return res.json();
            })
            .then(data => {
                const existingRow = data.values?.[0] || [];
                let rangeToWrite;
                let values;

                if (existingRow.length === 0 || existingRow[0] === undefined || existingRow[0] === "") { // Check if column B is empty
                    rangeToWrite = `Sheet1!B${targetRow}:G${targetRow}`; // Write to columns B and G
                    values = [[nowGMT, existingRow[2] || "", existingRow[3] || "", existingRow[4] || "", existingRow[5] || "", existingRow[6] || "", selectedUnits]]; // Write timestamp to B, preserve C-F, and units to G
                } else {
                    rangeToWrite = `Sheet1!G${targetRow}`; // Write to column G only
                    values = [[selectedUnits]]; // Write the units to column G
                }

                return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToWrite}?valueInputOption=RAW`, {
                    method: "PUT",
                    headers: {
                        "Authorization": `Bearer ${accessToken}`,
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({ values })
                });
            })
            .catch(error => {
                console.error("Failed to write Units:", error);
            });
        });
      };
      
      // Function to fetch the pre-filled name for the current row
      function fetchNameForRow(rowIndex) {
      const range = `Sheet1!A${rowIndex + 2}:A${rowIndex + 2}`; // Adjusted to use rowIndex + 2 to account for headers

      return safeApiCall(() => {
        return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${range}?majorDimension=ROWS`, {
          method: "GET",
          headers: {
            "Authorization": `Bearer ${accessToken}`,
          },
        })
          .then((response) => {
            if (!response.ok) throw response;
            return response.json();
          })
          .then((data) => {
            const editableName = document.getElementById("editableName");
            const name = data.values?.[0]?.[0] || "Sample Name";

            if (editableName) {
              editableName.value = name;

              // Apply gray color if the placeholder is used
              if (name === "Sample Name") {
                editableName.style.color = "#b5b7b9"; // Gray color
              } else {
                editableName.style.color = "#24292e"; // Default text color
              }
            }

            return name;
          })
          .catch((error) => {
            console.error("Failed to fetch name:", error);
            return "Sample Name"; // Default name on error
          });
      });
    }

      function fetchRowData(rowIndex) {
        const range = `Sheet1!A${rowIndex + 2}:P${rowIndex + 2}`; // Adjust N to your last column
        return safeApiCall(() => {
          return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${range}?majorDimension=ROWS`, {
            method: "GET",
            headers: {
              "Authorization": `Bearer ${accessToken}`,
            }
          })
            .then(res => {
              if (!res.ok) throw res;
              return res.json();
            })
            .then(data => data.values?.[0] || []);
        });
      }

      function fillInputsWithRowData(rowData) {
        // Editable Name (A)
        const editableName = document.getElementById("editableName");
        if (editableName) {
          const value = rowData[0] || "";
          editableName.value = value;
          editableName.style.color = value.trim() ? "#24292e" : "#b5b7b9";
          editableName.readOnly = true;
          editableName.addEventListener("focus", function handler() {
            editableName.style.color = "#24292e";
            editableName.readOnly = false;
            if (editableName.value === "Sample Name") editableName.value = "";
            editableName.removeEventListener("focus", handler);
          });
        }

        // Crew Description (E)
        const crewDescription = document.getElementById("CrewDescription");
        if (crewDescription) {
          const value = rowData[4] || "";
          crewDescription.value = value.trim() ? value : "Describe the sample...";
          crewDescription.style.color = value.trim() ? "#24292e" : "#b5b7b9";
          crewDescription.readOnly = true;
          crewDescription.addEventListener("focus", function handler() {
            crewDescription.style.color = "#24292e";
            crewDescription.readOnly = false;
            if (crewDescription.value === "Describe the sample...") crewDescription.value = "";
            crewDescription.removeEventListener("focus", handler);
          });
        }

        // Units (G)
        const units = document.getElementById("Units");
        if (units) {
          const value = rowData[6] || "";
          units.value = value.trim() ? value : "Units (e.g. g, kg, mL)";
          units.style.color = value.trim() ? "#24292e" : "#b5b7b9";
          units.readOnly = true;
          units.addEventListener("focus", function handler() {
            units.style.color = "#24292e";
            units.readOnly = false;
            if (units.value === "Units (e.g. g, kg, mL)") units.value = "";
            units.removeEventListener("focus", handler);
          });
        }

        // Mass Estimate (I)
        const massEstimate = document.getElementById("MassEstimate");
        if (massEstimate) {
          const value = rowData[8] || "";
          massEstimate.value = value.trim() ? value : "Estimated mass";
          massEstimate.style.color = value.trim() ? "#24292e" : "#b5b7b9";
          massEstimate.readOnly = true;
          massEstimate.addEventListener("focus", function handler() {
            massEstimate.style.color = "#24292e";
            massEstimate.readOnly = false;
            if (massEstimate.value === "Estimated mass") massEstimate.value = "";
            massEstimate.removeEventListener("focus", handler);
          });
        }

        // Volume Estimate (J)
        const volumeEstimate = document.getElementById("VolumeEstimate");
        if (volumeEstimate) {
          const value = rowData[9] || "";
          volumeEstimate.value = value.trim() ? value : "Estimated volume";
          volumeEstimate.style.color = value.trim() ? "#24292e" : "#b5b7b9";
          volumeEstimate.readOnly = true;
          volumeEstimate.addEventListener("focus", function handler() {
            volumeEstimate.style.color = "#24292e";
            volumeEstimate.readOnly = false;
            if (volumeEstimate.value === "Estimated volume") volumeEstimate.value = "";
            volumeEstimate.removeEventListener("focus", handler);
          });
        }

        // Container Number (K)
        const containerNumber = document.getElementById("ContainerNumber");
        if (containerNumber) {
          const value = rowData[10] || "";
          containerNumber.value = value.trim() ? value : "Container #";
          containerNumber.style.color = value.trim() ? "#24292e" : "#b5b7b9";
          containerNumber.readOnly = true;
          containerNumber.addEventListener("focus", function handler() {
            containerNumber.style.color = "#24292e";
            containerNumber.readOnly = false;
            if (containerNumber.value === "Container #") containerNumber.value = "";
            containerNumber.removeEventListener("focus", handler);
          });
        }

        // Contamination Notes (L)
        const contaminationNotes = document.getElementById("ContaminationNotes");
        if (contaminationNotes) {
          const value = rowData[11] || "";
          contaminationNotes.value = value.trim() ? value : "Contamination notes";
          contaminationNotes.style.color = value.trim() ? "#24292e" : "#b5b7b9";
          contaminationNotes.readOnly = true;
          contaminationNotes.addEventListener("focus", function handler() {
            contaminationNotes.style.color = "#24292e";
            contaminationNotes.readOnly = false;
            if (contaminationNotes.value === "Contamination notes") contaminationNotes.value = "";
            contaminationNotes.removeEventListener("focus", handler);
          });
        }

        // Sampling Tools (M)
        const samplingTools = document.getElementById("SamplingTools");
        if (samplingTools) {
          const value = rowData[12] || "";
          samplingTools.value = value.trim() ? value : "Sampling tool(s)";
          samplingTools.style.color = value.trim() ? "#24292e" : "#b5b7b9";
          samplingTools.readOnly = true;
          samplingTools.addEventListener("focus", function handler() {
            samplingTools.style.color = "#24292e";
            samplingTools.readOnly = false;
            if (samplingTools.value === "Sampling tool(s)") samplingTools.value = "";
            samplingTools.removeEventListener("focus", handler);
          });
        }

        // Dropdowns
        const sampleType = document.getElementById("SampleType");
        if (sampleType) {
          sampleType.value = rowData[5] || "";
        }
        const condition = document.getElementById("Condition");
        if (condition) {
          condition.value = rowData[7] || "";
        }
        const station = document.getElementById("EVAnumber");
        if (station) {
          station.value = rowData[14] || "";
        }
        const evaNumber = document.getElementById("Station");
        if (evaNumber) {
          evaNumber.value = rowData[15] || "";
        }

        // Checkboxes
        const planned = document.getElementById("Planned");
        const unplanned = document.getElementById("Unplanned");
        if (planned) planned.checked = rowData[13] === "Planned";
        if (unplanned) unplanned.checked = rowData[13] === "Unplanned";

        // Update the entry number label
        const entryNumber = document.getElementById("entryNumber");
        if (entryNumber) {
          entryNumber.innerText = `Entry #${count}`;
        }

        // Start/End Time (B, D)
        const startTimeDisplay = document.getElementById("startTimeDisplay");
        const endTimeDisplay = document.getElementById("endTimeDisplay");
        if (startTimeDisplay) {
          // Only clear the display, do not show start time on fetch
          startTimeDisplay.textContent = "";
        }
        if (endTimeDisplay) {
          const endVal = rowData[3] || "";
          let timeOnly = "";
          if (endVal) {
            const d = new Date(endVal);
            if (!isNaN(d)) {
              timeOnly = d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
            }
          }
          endTimeDisplay.textContent = timeOnly ? `End: ${timeOnly}` : "";
        }
      }

      let tokenClient;
      const CLIENT_ID = '263288053429-39j61v5mij7mhrtqg9peqov1i33nedc6.apps.googleusercontent.com';
      const SPREADSHEET_ID = '1efR88nP511yGEPgjsR9KcT0nE2TQImzuxyYYZ6uUKGo';
      let accessToken = localStorage.getItem('accessToken');
      let count = 1;

      // arbitrary variables to hold the values of the checkboxes
      const checkbox1 = document.getElementById('Planned');
      const checkbox2 = document.getElementById('Unplanned');

      // Add event listeners to the checkboxes to ensure only one can be checked at a time
      checkbox1.addEventListener('change', () => { 
        if (checkbox1.checked) {
          checkbox2.checked = false;
          // Write label to sheet
          safeApiCall(() => writeCheckboxToSheet('Planned', count));
        }
      });
      checkbox2.addEventListener('change', () => { 
        if (checkbox2.checked) {
          checkbox1.checked = false;
          // Write label to sheet
          safeApiCall(() => writeCheckboxToSheet('Unplanned', count));
        }
      });

      // Function to initialize the token client
      // This function is called when the page loads to set up the token client.
      function initTokenClient() {
        tokenClient = google.accounts.oauth2.initTokenClient({
          client_id: CLIENT_ID,
          scope: 'https://www.googleapis.com/auth/spreadsheets',
          callback: (tokenResponse) => {
            if (tokenResponse.access_token) {
              accessToken = tokenResponse.access_token;
              localStorage.setItem('accessToken', accessToken);
              console.log("Access token refreshed.");
            } else {
              console.error("Failed to refresh access token.");
            }
          }
        });
      }
  
      // // Function to refresh the access token
      // This function is called when the access token is expired or invalid.
      function refreshAccessToken(callback) {
        if (!tokenClient) {
          alert("Session expired. Please sign in again.");
          window.location.href = 'index.html'; // Redirect to your login page
          return;
        }

        tokenClient.callback = (tokenResponse) => {
          if (tokenResponse.access_token) {
            accessToken = tokenResponse.access_token;
            localStorage.setItem('accessToken', accessToken);
            console.log("Token refreshed.");
            // Force a browser page refresh after successful token refresh
            window.location.reload();
            // If you want to call the callback after reload, you can use sessionStorage to flag and handle it on load
            // if (callback) callback();
          } else {
            alert("Session expired. Please sign in again.");
            localStorage.removeItem('accessToken');
            window.location.href = 'index.html'; // Redirect to your login page
          }
        };

        tokenClient.requestAccessToken({ prompt: '' });
      }
      
      // Function to handle API calls safely
      // This function checks if the access token is available and valid before making API calls.
      function safeApiCall(apiFunction) {
      if (!accessToken) {
        console.warn("No access token. Attempting to sign in...");
        return new Promise((resolve, reject) => {
          tokenClient.callback = (tokenResponse) => {
            if (tokenResponse.access_token) {
              accessToken = tokenResponse.access_token;
              localStorage.setItem('accessToken', accessToken);
              console.log("Access token obtained.");
              apiFunction().then(resolve).catch(reject); // Retry the API call
            } else {
              alert("Sign-in required. Please sign in to continue.");
              reject("No access token");
            }
          };
          tokenClient.requestAccessToken({ prompt: 'consent' }); // Bring up the GIS sign-in window
        });
      }

      return apiFunction().catch(err => {
        if (err?.status === 401 || err?.message?.includes('401')) {
          console.warn("Access token expired. Attempting refresh...");
          return new Promise((resolve, reject) => {
            refreshAccessToken(() => {
              apiFunction().then(resolve).catch(reject); // Retry the API call
            });
          });
        } else {
          console.error("API error:", err);
          throw err; // Re-throw the error for further handling
        }
      });
    }

      // Function to update the label and footer count
      function updateLabel() {
        const entryNumber = document.getElementById("entryNumber");
        const footerCount = document.getElementById("footerCount");

        if (entryNumber) {
          entryNumber.innerText = `Entry #${count}`;
          console.log("Label updated to:", entryNumber.innerText); // Debugging log
        } else {
          console.error("Entry number element not found.");
        }

        if (footerCount) {
          footerCount.innerText = `${count}`;
          console.log("Footer updated to:", footerCount.innerText); // Debugging log
        } else {
          console.error("Footer element not found.");
        }
      }
      // Function to clear all input fields
      function clearFields() {
        document.querySelectorAll('input[type="text"]').forEach(input => input.value = "");
        document.querySelectorAll('select').forEach(select => select.selectedIndex = 0);
        document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => checkbox.checked = false);
        // Clear time displays
        const startTimeDisplay = document.getElementById("startTimeDisplay");
        const endTimeDisplay = document.getElementById("endTimeDisplay");
        if (startTimeDisplay) startTimeDisplay.textContent = "";
        if (endTimeDisplay) endTimeDisplay.textContent = "";
      }

      // Start Time Button Logic
      const startButton = document.getElementById("startTimeButton");
      startButton.addEventListener("click", () => {
        const now = new Date();
        const timeStr = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        safeApiCall(() => writeStartTime(count)).then(() => {
          const startTimeDisplay = document.getElementById("startTimeDisplay");
          if (startTimeDisplay) startTimeDisplay.textContent = `Start: ${timeStr}`;
        });
      });

      // End Time Button Logic
      const endButton = document.getElementById("endTimeButton");
      endButton.addEventListener("click", () => {
        const now = new Date();
        const timeStr = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        safeApiCall(() => writeEndTime(count)).then(() => {
          const endTimeDisplay = document.getElementById("endTimeDisplay");
          if (endTimeDisplay) endTimeDisplay.textContent = `End: ${timeStr}`;
        });
      });

      function insertRowBelow(targetRowIndex) {
        return safeApiCall(() => {
            const sheetId = 0; // Usually 0 for the first sheet
            const insertRowIndex = targetRowIndex + 1;

            const requestBody = {
                requests: [
                    {
                        insertDimension: {
                            range: {
                                sheetId: sheetId,
                                dimension: "ROWS",
                                startIndex: insertRowIndex,
                                endIndex: insertRowIndex + 1,
                            },
                            inheritFromBefore: true,
                        },
                    },
                ],
            };

            return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}:batchUpdate`, {
                method: "POST",
                headers: {
                    "Authorization": `Bearer ${accessToken}`,
                    "Content-Type": "application/json",
                },
                body: JSON.stringify(requestBody),
            })
                .then((response) => {
                    if (!response.ok) throw response;
                    return response.json();
                })
                .then((data) => {
                    console.log("Row inserted successfully:", data);

                    // Increment count to reflect the new row
                    count++;
                    localStorage.setItem('count', count);
                    console.log("Count updated to:", count);

                    // Update the label to reflect the new entry
                    updateLabel();

                    // Only now: clear and fetch for the new row
                    clearFields();

                    // Set editableName to "Enter Sample Name" in grey and as placeholderer
                    const editableName = document.getElementById("editableName");
                    if (editableName) {
                        editableName.value = "Enter Sample Name";
                        editableName.placeholder = "Enter Sample Name";
                        editableName.style.color = "#b5b7b9";
                        editableName.readOnly = false;
                        editableName.focus();
                        editableName.addEventListener("focus", function handler() {
                            if (editableName.value === "Enter Sample Name") editableName.value = "";
                            editableName.style.color = "#24292e";
                            editableName.readOnly = false;
                            editableName.removeEventListener("focus", handler);
                        });
                    }

                    fetchWithTimeoutAndPrompt(count - 1);
                })
                .catch((error) => {
                    console.error("Failed to insert row:", error);
                });
        });
    }

      // Function to write the updated name to the spreadsheet
      function writeNameToSheet(rowIndex, name) {
        const range = `Sheet1!A${rowIndex + 2}:A${rowIndex + 2}`; // Adjusted to use rowIndex + 2 to account for headers
        const values = [[name]];

        return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${range}?valueInputOption=RAW`, {
          method: "PUT",
          headers: {
            "Authorization": `Bearer ${accessToken}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ values }),
        })
          .then((response) => {
            if (!response.ok) throw response;
            return response.json();
          })
          .then((data) => {
            console.log("Name updated successfully:", data);
          })
          .catch((error) => {
            console.error("Failed to update name:", error);
          });
      }

      // Initialize the editable name and entry number
      function initializeNameAndEntry() {
        const editableName = document.getElementById("editableName");
        const entryNumber = document.getElementById("entryNumber");

        // Fetch and display the name for the current row
        fetchNameForRow(count - 1).then((name) => {
          editableName.value = name;

          // Apply gray color if the placeholder is used
          if (name === "Sample Name") {
            editableName.style.color = "#8e9296"; // Gray color for placeholder
          } else {
            editableName.style.color = "#24292e"; // Default text color
          }
        });

        // Update the entry number
        entryNumber.innerText = `Entry #${count}`;

        // Add event listener for editing the name
        editableName.addEventListener("keydown", (event) => {
          if (event.key === "Enter" || event.keyCode === 13) {
            const updatedName = editableName.value.trim();
            if (updatedName) {
              writeNameToSheet(count - 1, updatedName).then(() => {
                // Apply the "saved" style
                editableName.classList.add("saved");
                editableName.style.color = "#0969da"; // Set color to blue when saved
                setTimeout(() => {
                  editableName.classList.remove("saved");
                  editableName.style.color = "#24292e"; // Reset to default text color
                }, 2000); // Remove the style after 2 seconds
              });
            }
          }
        });
      }

      function handleInputEvent(event, apiFunction) {
        const key = event.key || event.keyCode || event.which;

        // Check for Enter key (keyCode 13)
        if (key === "Enter" || key === 13) {
            const value = event.target.value.trim();
            if (value) {
                safeApiCall(() => apiFunction(value, count)) // Pass count here
                    .then(() => {
                        console.log(`${event.target.id} written successfully.`);
                        // Flash blue, then revert to black
                        event.target.classList.add("saved");
                        event.target.style.color = "#0969da";
                        setTimeout(() => {
                            event.target.classList.remove("saved");
                            event.target.style.color = "#24292e";
                        }, 2000);
                    })
                    .catch(err => {
                        console.error(`Failed to write ${event.target.id}:`, err);
                    });
            }
        }
      }

      function handleDropdownChange(event, apiFunction) {
        const value = event.target.value;
        if (value) {
            safeApiCall(() => apiFunction(value, count))
                .then(() => {
                    console.log(`${event.target.id} written successfully.`);
                })
                .catch(err => {
                    console.error(`Failed to write ${event.target.id}:`, err);
                });
            }
               }
  
      window.onload = () => {
        if (!localStorage.getItem('accessToken')) {
          alert("Session expired. Please sign in again.");
          window.location.href = 'index.html';
          return;
        }

        initTokenClient();

        count = parseInt(localStorage.getItem('count')) || 1;
        updateLabel();
        initializeNameAndEntry();
        fetchWithTimeoutAndPrompt(count - 1);

        // Attach event listeners to all text inputs
        document.querySelectorAll('input[type="text"]').forEach(input => {
            input.addEventListener("keydown", event => {
                switch (input.id) {
                    case "CrewDescription":
                        handleInputEvent(event, (value) => writeCrewDescriptionToSheet(value, count));
                        break;
                    case "Units":
                        handleInputEvent(event, (value) => writeUnitsToSheet(value, count));
                        break;
                    case "MassEstimate":
                        handleInputEvent(event, (value) => writeMassToSheet(value, count));
                        break;
                    case "VolumeEstimate":
                        handleInputEvent(event, (value) => writeVolumeToSheet(value, count));
                        break;
                    case "ContainerNumber":
                        handleInputEvent(event, (value) => writeContainerToSheet(value, count));
                        break;
                    case "ContaminationNotes":
                        handleInputEvent(event, (value) => writeContaminationToSheet(value, count));
                        break;
                    case "SamplingTools":
                        handleInputEvent(event, (value) => writeToolsToSheet(value, count));
                        break;
                    default:
                        console.warn(`No handler defined for input: ${input.id}`);
                }
            });
        });

        // Attach event listener to the plus button
        const addRowButton = document.getElementById("addRowButton");
        addRowButton.addEventListener("click", () => {
          console.log("Plus button clicked"); // Debugging log
          insertRowBelow(count); // Pass the current row index
        });

        // Attach event listeners to all dropdowns
        document.querySelectorAll('select').forEach(select => {
            select.addEventListener("change", event => {
                switch (select.id) {
                    case "SampleType":
                        handleDropdownChange(event, (value) => writeSampleTypeToSheet(value, count));
                        break;
                    case "Condition":
                        handleDropdownChange(event, (value) => writeConditionToSheet(value, count));
                        break;
                    case "Station":
                        handleDropdownChange(event, (value) => writeStationToSheet(value, count));
                        break;
                    case "EVAnumber":
                        handleDropdownChange(event, (value) => writeEVAToSheet(value, count));
                        break;
                    default:
                        console.warn(`No handler defined for dropdown: ${select.id}`);
                }
            });
        });

        // Attach event listeners to forward and back buttons
        const backButton = document.getElementById("backButton");
        const nextButton = document.getElementById("nextButton");

        backButton.addEventListener("click", () => {
            if (count > 1) {
                count--;
                localStorage.setItem('count', count);
                clearFields();
                updateLabel();
                fetchWithTimeoutAndPrompt(count - 1);
            }
        });

        nextButton.addEventListener("click", () => {
            count++;
            localStorage.setItem('count', count);
            clearFields();
            updateLabel();
            fetchWithTimeoutAndPrompt(count - 1);
        });
      };
    </script>
  </body>
</html>