<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Submit Data to Google Sheets</title>

  <!-- Google Identity Services -->
  <script src="https://accounts.google.com/gsi/client" async defer></script>

  <style>
    /* Base styles */
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
      background-color: #f6f8fa; /* Light gray background like GitHub */
      color: #24292e; /* Dark text color */
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 20px;
      margin: 0;
    }

    .container {
      display: flex;
      flex-direction: column;
      gap: 20px;
      background-color: #ffffff; /* White background for the container */
      padding: 24px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); /* Subtle shadow for depth */
      max-width: 800px;
      width: 100%;
    }

    /* Section styles */
    .row-layout,
    .second-row-layout,
    .third-row-layout,
    .bottom-section,
    .last-section {
      display: flex;
      flex-direction: column;
      gap: 10px;
      padding: 16px;
      border: 1px solid #d0d7de; /* Light border for separation */
      border-radius: 6px;
      background-color: #ffffff;
    }

    /* First Row Layout */
    .row-layout {
      display: flex;
      flex-direction: row;
      justify-content: space-between;
      align-items: center;
      gap: 20px;
      width: 100%; /* Ensure it matches the container width */
      box-sizing: border-box; /* Include padding and border in the width calculation */
    }

    /* Label Box */
    .label-box {
      display: flex; /* Take up available space on the left */
      flex-direction: row;
      background-color: #f6f8fa; /* Light gray background */
      padding: 16px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      text-align: center;
      font-size: 1.2em;
      font-weight: bold;
      color: #24292e;
      box-sizing: border-box; /* Include padding in the width calculation */
    }

    /* Button Group Box */
    .button-group-box {
      display: flex;
      gap: 10px;
      background-color: #ffffff; /* White background */
      padding: 16px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      box-sizing: border-box; /* Include padding in the width calculation */
    }

    /* Buttons */
    .button {
      padding: 8px 16px;
      font-size: 14px;
      font-weight: 600;
      background-color: #2da44e; /* GitHub green */
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }

    .button:hover {
      background-color: #218838; /* Darker green on hover */
    }

    .button.secondary {
      background-color: #f6f8fa; /* Light gray for secondary buttons */
      color: #24292e;
      border: 1px solid #d0d7de;
    }

    .button.secondary:hover {
      background-color: #eaeef2; /* Slightly darker gray on hover */
    }

    /* Labels */
    label {
      font-size: 14px;
      font-weight: 600;
      color: #57606a; /* Subtle gray for labels */
    }

    /* Inputs and Selects */
    input[type="text"],
    select {
      width: 100%;
      padding: 8px 12px;
      font-size: 14px;
      border: 1px solid #d0d7de;
      border-radius: 6px;
      background-color: #ffffff;
      color: #24292e;
      outline: none;
      transition: border-color 0.2s ease;
    }

    input[type="text"]:focus,
    select:focus {
      border-color: #0969da; /* GitHub blue for focus */
      box-shadow: 0 0 0 3px rgba(9, 105, 218, 0.3); /* Subtle blue outline */
    }

    /* Checkboxes */
    .checkbox-label {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 1.2em; /* Make the text larger */
      font-weight: bold;
      color: #24292e;
    }

    .checkbox-label input {
      width: 24px; /* Make the checkbox larger */
      height: 24px;
      cursor: pointer;
    }

    /* Textarea */
    textarea {
      width: 100%;
      height: 100px;
      padding: 8px 12px;
      font-size: 14px;
      border: 1px solid #d0d7de;
      border-radius: 6px;
      background-color: #ffffff;
      color: #24292e;
      resize: none;
      outline: none;
      transition: border-color 0.2s ease;
    }

    textarea:focus {
      border-color: #0969da;
      box-shadow: 0 0 0 3px rgba(9, 105, 218, 0.3);
    }

    /* Grid layout for bottom section */
    .grid-3col {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 16px;
    }

    /* Section headers */
    .section-header {
      font-size: 16px;
      font-weight: bold;
      color: #24292e;
      margin-bottom: 8px;
    }

    /* Third Row Layout */
    .third-row-layout {
      display: flex;
      flex-direction: column;
      gap: 10px;
      padding: 16px;
      border: 1px solid #d0d7de; /* Light border for separation */
      border-radius: 6px;
      background-color: #ffffff;
      box-sizing: border-box; /* Include padding and border in the width calculation */
    }

    /* Input Box */
    .third-row-layout input[type="text"] {
      width: 100%; /* Ensure it spans the full width of the section */
      padding: 8px 12px;
      font-size: 14px;
      border: 1px solid #d0d7de;
      border-radius: 6px;
      background-color: #ffffff;
      color: #24292e;
      outline: none;
      box-sizing: border-box; /* Include padding and border in the width calculation */
      transition: border-color 0.2s ease;
    }

    .third-row-layout input[type="text"]:focus {
      border-color: #0969da; /* GitHub blue for focus */
      box-shadow: 0 0 0 3px rgba(9, 105, 218, 0.3); /* Subtle blue outline */
    }

    /* Second Row Layout */
    .second-row-layout {
      display: flex;
      flex-direction: row;
      justify-content: space-between; /* Space out the two boxes */
      align-items: center;
      padding: 16px;
      border: 1px solid #d0d7de; /* Light border for separation */
      border-radius: 6px;
      background-color: #ffffff;
      box-sizing: border-box;
    }

    /* Dropdown Group Box */
    .dropdown-group-box {
      display: flex;
      flex-direction: row; /* Keep dropdowns horizontal */
      gap: 20px; /* Add space between dropdowns */
      padding: 16px;
      background-color: #f6f8fa; /* Light gray background */
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      width: 48%; /* Match the width of the checkbox group box */
      box-sizing: border-box;
      justify-content: flex-start; /* Align dropdowns inside the box */
      align-items: center; /* Vertically center the dropdowns */
    }

    /* Dropdown Inputs */
    .dropdown-input select {
      width: 100%; /* Ensure dropdown spans the full width of its container */
      padding: 8px 12px; /* Reduce padding for a cleaner look */
      font-size: 20px; /* Match font size with other inputs */
      border: 1px solid #d0d7de;
      border-radius: 6px;
      background-color: #ffffff;
      color: #24292e;
      outline: none;
      box-sizing: border-box;
      transition: border-color 0.2s ease;
    }

    .dropdown-input select:focus {
      border-color: #0969da; /* GitHub blue for focus */
      box-shadow: 0 0 0 3px rgba(9, 105, 218, 0.3); /* Subtle blue outline */
    }

    /* Checkbox Group Box */
    .checkbox-group-box {
      display: flex;
      flex-direction: row; /* Keep checkboxes horizontal */
      gap: 20px; /* Add space between checkboxes */
      padding: 16px;
      background-color: #f6f8fa; /* Light gray background */
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      width: 48%; /* Match the width of the dropdown group box */
      box-sizing: border-box;
      justify-content: flex-start; /* Align checkboxes inside the box */
      align-items: center; /* Vertically center the checkboxes */
    }

    /* Checkbox Labels */
    .checkbox-label {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 1.2em; /* Make the text larger */
      font-weight: bold;
      color: #24292e;
    }

    /* Checkboxes */
    .checkbox-label input {
      width: 28px; /* Make the checkbox larger */
      height: 28px;
      cursor: pointer;
    }
    /* Editable Name */
    .editable-name {
      font-size: 1.8em !important; /* Ensure the font size is applied */
      font-weight: bold; /* Make the text bold */
      color: #24292e; /* Default text color */
      border: none;
      background-color: transparent;
      outline: none;
      text-align: center;
      width: 150%;
      cursor: text;
      transition: color 0.2s ease, font-weight 0.2s ease;
    }

    .editable-name:focus {
      border-bottom: 2px solid #0969da; /* Subtle underline when editing */
    }

    /* Bold and Colored Name After Editing */
    .editable-name.saved {
      font-weight: bold;
      color: #0969da; /* GitHub blue */
    }

    /* Entry Number */
    .entry-number {
      visibility: hidden;
      font-size: 0.4em;
      color: #57606a; /* Subtle gray */
      margin-top: 4px;
    }
    .green-button {
      padding: 4px 10px;
      font-size: 16px;
      font-weight: bold;
      background-color: #2da44e; /* GitHub green */
      color: white;
      border: none;
      border-radius: 2%; /* Circular button */
      cursor: pointer;
      transition: background-color 0.2s ease;
      margin-left: 10px; /* Add spacing from the label */
    }

    .green-button:hover {
      background-color: #218838; /* Darker green on hover */
    }
    /* Footer */
    .footer {
      text-align: center;
      font-size: 12px; /* Small font size */
      color: #57606a; /* Subtle gray color */
      margin-top: 20px; /* Add spacing from the content above */
      padding: 10px 0;
      border-top: 1px solid #d0d7de; /* Subtle top border for separation */
    } 
  </style>
</head>
<body>
    <div class="container">
        <!-- Button row, this should be a back and next arrow -->
        <div class="row-layout">
          <!-- Label Box -->
          <div class="label-box">
            <input id="editableName" class="editable-name" type="text" placeholder="fetching..." />
            <div id="entryNumber" class="entry-number">Entry #0</div>
            <button id="addRowButton" class="button green-button">+</button>
          </div>

          <!-- Start/End Time Buttons Box -->
          <div class="button-group-box">
            <button class="button">Start Time</button>
            <button class="button">End Time</button>
          </div>

          <!-- Back/Next Buttons Box -->
          <div class="button-group-box">
            <button class="button">&#8592; Back</button>
            <button class="button">Next &#8594;</button>
          </div>
        </div>

        <div class="second-row-layout">
          <!-- Dropdown Group Box -->
          <div class="dropdown-group-box">
            <label class="dropdown-input">
              <select id="Station" name="Station:">
                <option value="" disabled selected>Station...</option>
                <option value="Location 1">Location 1</option>
                <option value="Location 2">Location 2</option>
                <option value="Location 3">Location 3</option>
                <option value="Location 4">Location 4</option>
              </select>
            </label>
            <label class="dropdown-input">
              <select id="EVAnumber" name="EVA Number:">
                <option value="" disabled selected>EVA...</option>
                <option value="Location A">A</option>
                <option value="Location B">B</option>
                <option value="Location C">C</option>
                <option value="Location D">D</option>
              </select>
            </label>
          </div>
        
          <!-- Checkbox Group Box -->
          <div class="checkbox-group-box">
            <label class="checkbox-label">
              <input type="checkbox" id="Planned" name="Planned" value="True">
              Planned
            </label>
            <label class="checkbox-label">
              <input type="checkbox" id="Unplanned" name="Unplanned" value="True">
              Unplanned
            </label>
          </div>
        </div>

        <div class="third-row-layout">
            <label for="CrewDescription">Crew Description:</label><br>
            <input type="text" id="CrewDescription" name="Crew Description">
        </div>
        <div class="bottom-section">
            <div class="grid-3col">
              <!-- Row 1: Labels -->
              <label for="SampleType">Sample Type:</label>
              <label for="Units">Units:</label>
              <label for="Condition">Condition:</label>
          
              <!-- Row 2: Inputs -->
              <select id="SampleType" name="Sample Type:">
                <option value=""></option>
                <option value="Rake">Rake</option>
                <option value="Scoop">Scoop</option>
                <option value="Chip">Chip</option>
                <option value="Float">Float</option>
                <option value="Skim">Skim</option>
                <option value="Single Drive Tube">Single Drive Tube</option>
                <option value="Double Drive Tube">Double Drive Tube</option>
              </select>
              
              <input type="text" id="Units" name="Unit:">
              
              <select id="Condition" name="Condition:">
                <option value=""></option>
                <option value="Illuminated">Illuminated</option>
                <option value="Shadowed">Shadowed</option>
                <option value="Undisturbed">Undisturbed</option>
                <option value="Disturbed">Disturbed</option>
                <option value="Cold">Cold</option>
              </select>
          
              <!-- Row 3: Labels -->
              <label for="MassEstimate">Mass Estimate:</label>
              <label for="VolumeEstimate">Volume Estimate:</label>
              <label for="ContainerNumber">Container Number(s):</label>
          
              <!-- Row 4: Inputs -->
              <input type="text" id="MassEstimate" name="Mass Estimate:">
              <input type="text" id="VolumeEstimate" name="Volume Estimate:">
              <input type="text" id="ContainerNumber" name="Container Number(s)">
            </div>
        </div>
        <div class="Last-Section">
            <div class="last-section-layout">
                <label for="ContaminationNotes">Contamination Notes:</label><br>
                <input type="text" id="ContaminationNotes" name="Contamination Notes">
            </div>
            <div class="last-section-layout">
                <label for="SamplingTools">Sampling Tool(s):</label><br>
                <input type="text" id="SamplingTools" name="Sampling Tool(s)">
            </div>
        </div>
        <div class="footer" id="footerCount">1</div>
        
    </div>

    <script>
      // function for writing sampling tools
      function writeToolsToSheet(selectedTools) {
      const targetRow = count + 1;
        const nowGMT = new Date().toISOString();  // Current time in GMT format
        const rangeToWrite = `Sheet1!A${targetRow}:M${targetRow}`;  // Write to column M of the target row
        const rangeToCheck = `Sheet1!A${targetRow}:B${targetRow}`;  // Check the first two columns (A,B)
        fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToCheck}?majorDimension=ROWS`, {
              method: "GET",
              headers: {
                  "Authorization": `Bearer ${accessToken}`,
              }
          })
          .then(res => {
              if (!res.ok) throw res;
              return res.json();
          })
          .then(data => {
              let existingRow = data.values?.[0] || [];

              let values;

              // Check if columns A and B are empty
              if (existingRow.length === 0 || existingRow[0] === "" || existingRow[1] === "") {
                  // If A and B are empty, initialize them with count and timestamp, and write the crew description in column N
                  values = [
                      [count.toString(), nowGMT, existingRow[2], existingRow[3], existingRow[4], existingRow[5], existingRow[6], existingRow[7], existingRow[8], existingRow[9], existingRow[10], existingRow[11], selectedTools]  // Initialize with count, timestamp, and entry
                  ];
              } else {
                  // If A and B are not empty, only update the entry in its column
                  values = [
                      [existingRow[0], existingRow[1], existingRow[2], existingRow[3], existingRow[4], existingRow[5], existingRow[6], existingRow[7], existingRow[8], existingRow[9], existingRow[10], existingRow[11], selectedTools]
                  ];
              }

              // Update the row in the sheet with the new values
              return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToWrite}?valueInputOption=RAW`, {
                  method: "PUT",
                  headers: {
                      "Authorization": `Bearer ${accessToken}`,
                      "Content-Type": "application/json"
                  },
                  body: JSON.stringify({ values })
              });
          })
          .then(response => response.json())
          .then(data => {
              console.log("Sampling Tools written to Sheet...", data);
          })
          .catch(error => {
              console.error("Failed to write Sampling Tools:", error);
          });
      }
      // function for writing Contamination Notes:
      function writeContaminationToSheet(selectedContamination) {
        const targetRow = count + 1;
        const nowGMT = new Date().toISOString();  // Current time in GMT format
        const rangeToWrite = `Sheet1!A${targetRow}:L${targetRow}`;  // Write to column L of the target row
        const rangeToCheck = `Sheet1!A${targetRow}:B${targetRow}`;  // Check the first two columns (A,B)
        fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToCheck}?majorDimension=ROWS`, {
              method: "GET",
              headers: {
                  "Authorization": `Bearer ${accessToken}`,
              }
          })
          .then(res => {
              if (!res.ok) throw res;
              return res.json();
          })
          .then(data => {
              let existingRow = data.values?.[0] || [];

              let values;

              // Check if columns A and B are empty
              if (existingRow.length === 0 || existingRow[0] === "" || existingRow[1] === "") {
                  // If A and B are empty, initialize them with count and timestamp, and write the crew description in column N
                  values = [
                      [count.toString(), nowGMT, existingRow[2], existingRow[3], existingRow[4], existingRow[5], existingRow[6], existingRow[7], existingRow[8], existingRow[9], existingRow[10], selectedContamination]  // Initialize with count, timestamp, and entry
                  ];
              } else {
                  // If A and B are not empty, only update the entry in its column
                  values = [
                      [existingRow[0], existingRow[1], existingRow[2], existingRow[3], existingRow[4], existingRow[5], existingRow[6], existingRow[7], existingRow[8], existingRow[9], existingRow[10], selectedContamination]
                  ];
              }

              // Update the row in the sheet with the new values
              return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToWrite}?valueInputOption=RAW`, {
                  method: "PUT",
                  headers: {
                      "Authorization": `Bearer ${accessToken}`,
                      "Content-Type": "application/json"
                  },
                  body: JSON.stringify({ values })
              });
          })
          .then(response => response.json())
          .then(data => {
              console.log("Contamination Notes written to Sheet...", data);
          })
          .catch(error => {
              console.error("Failed to write Contamination Notes:", error);
          });
      }
      //function for writing Container Number(s) to sheet
      function writeContainerToSheet(selectedContainer) {
        const targetRow = count + 1;
        const nowGMT = new Date().toISOString();  // Current time in GMT format
        const rangeToWrite = `Sheet1!A${targetRow}:K${targetRow}`;  // Write to column K of the target row
        const rangeToCheck = `Sheet1!A${targetRow}:B${targetRow}`;  // Check the first two columns (A,B)
        fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToCheck}?majorDimension=ROWS`, {
              method: "GET",
              headers: {
                  "Authorization": `Bearer ${accessToken}`,
              }
          })
          .then(res => {
              if (!res.ok) throw res;
              return res.json();
          })
          .then(data => {
              let existingRow = data.values?.[0] || [];

              let values;

              // Check if columns A and B are empty
              if (existingRow.length === 0 || existingRow[0] === "" || existingRow[1] === "") {
                  // If A and B are empty, initialize them with count and timestamp, and write the crew description in column N
                  values = [
                      [count.toString(), nowGMT, existingRow[2], existingRow[3], existingRow[4], existingRow[5], existingRow[6], existingRow[7], existingRow[8], existingRow[9], selectedContainer]  // Initialize with count, timestamp, and entry
                  ];
              } else {
                  // If A and B are not empty, only update the entry in its column
                  values = [
                      [existingRow[0], existingRow[1], existingRow[2], existingRow[3], existingRow[4], existingRow[5], existingRow[6], existingRow[7], existingRow[8], existingRow[9], selectedContainer]
                  ];
              }

              // Update the row in the sheet with the new values
              return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToWrite}?valueInputOption=RAW`, {
                  method: "PUT",
                  headers: {
                      "Authorization": `Bearer ${accessToken}`,
                      "Content-Type": "application/json"
                  },
                  body: JSON.stringify({ values })
              });
          })
          .then(response => response.json())
          .then(data => {
              console.log("Container Number(s) written to Sheet...", data);
          })
          .catch(error => {
              console.error("Failed to write Container Number(s):", error);
          });
      }

      //function for writing Volume Estimate
      function writeVolumeToSheet(selectedVolume) {
        const targetRow = count + 1;
        const nowGMT = new Date().toISOString();  // Current time in GMT format
        const rangeToWrite = `Sheet1!A${targetRow}:J${targetRow}`;  // Write to column J of the target row
        const rangeToCheck = `Sheet1!A${targetRow}:B${targetRow}`;  // Check the first two columns (A,B)
        fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToCheck}?majorDimension=ROWS`, {
              method: "GET",
              headers: {
                  "Authorization": `Bearer ${accessToken}`,
              }
          })
          .then(res => {
              if (!res.ok) throw res;
              return res.json();
          })
          .then(data => {
              let existingRow = data.values?.[0] || [];

              let values;

              // Check if columns A and B are empty
              if (existingRow.length === 0 || existingRow[0] === "" || existingRow[1] === "") {
                  // If A and B are empty, initialize them with count and timestamp, and write the crew description in column N
                  values = [
                      [count.toString(), nowGMT, existingRow[2], existingRow[3], existingRow[4], existingRow[5], existingRow[6], existingRow[7], existingRow[8], selectedVolume]  // Initialize with count, timestamp, and entry
                  ];
              } else {
                  // If A and B are not empty, only update the entry in its column
                  values = [
                      [existingRow[0], existingRow[1], existingRow[2], existingRow[3], existingRow[4], existingRow[5], existingRow[6], existingRow[7], existingRow[8], selectedVolume]
                  ];
              }

              // Update the row in the sheet with the new values
              return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToWrite}?valueInputOption=RAW`, {
                  method: "PUT",
                  headers: {
                      "Authorization": `Bearer ${accessToken}`,
                      "Content-Type": "application/json"
                  },
                  body: JSON.stringify({ values })
              });
          })
          .then(response => response.json())
          .then(data => {
              console.log("Volume Estimate written to Sheet...", data);
          })
          .catch(error => {
              console.error("Failed to write Volume Estimate:", error);
          });
      }
      // function for writing Mass Estimate
      function writeMassToSheet(selectedMass) {
        const targetRow = count + 1;
        const nowGMT = new Date().toISOString();  // Current time in GMT format
        const rangeToWrite = `Sheet1!A${targetRow}:I${targetRow}`;  // Write to column I of the target row
        const rangeToCheck = `Sheet1!A${targetRow}:B${targetRow}`;  // Check the first two columns (A,B)
        fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToCheck}?majorDimension=ROWS`, {
              method: "GET",
              headers: {
                  "Authorization": `Bearer ${accessToken}`,
              }
          })
          .then(res => {
              if (!res.ok) throw res;
              return res.json();
          })
          .then(data => {
              let existingRow = data.values?.[0] || [];

              let values;

              // Check if columns A and B are empty
              if (existingRow.length === 0 || existingRow[0] === "" || existingRow[1] === "") {
                  // If A and B are empty, initialize them with count and timestamp, and write the crew description in column N
                  values = [
                      [count.toString(), nowGMT, existingRow[2], existingRow[3], existingRow[4], existingRow[5], existingRow[6], existingRow[7], selectedMass]  // Initialize with count, timestamp, and entry
                  ];
              } else {
                  // If A and B are not empty, only update the entry in its column
                  values = [
                      [existingRow[0], existingRow[1], existingRow[2], existingRow[3], existingRow[4], existingRow[5], existingRow[6], existingRow[7], selectedMass]
                  ];
              }

              // Update the row in the sheet with the new values
              return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToWrite}?valueInputOption=RAW`, {
                  method: "PUT",
                  headers: {
                      "Authorization": `Bearer ${accessToken}`,
                      "Content-Type": "application/json"
                  },
                  body: JSON.stringify({ values })
              });
          })
          .then(response => response.json())
          .then(data => {
              console.log("Mass Estimate written to Sheet...", data);
          })
          .catch(error => {
              console.error("Failed to write Mass Estimate:", error);
          });
      }
      //function for writing Condition
      function writeConditionToSheet(selectedCondition) {
        const targetRow = count + 1;
        const nowGMT = new Date().toISOString();  // Current time in GMT format
        const rangeToWrite = `Sheet1!A${targetRow}:H${targetRow}`;  // Write to column H of the target row
        const rangeToCheck = `Sheet1!A${targetRow}:B${targetRow}`;  // Check the first two columns (A,B)
        fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToCheck}?majorDimension=ROWS`, {
              method: "GET",
              headers: {
                  "Authorization": `Bearer ${accessToken}`,
              }
          })
          .then(res => {
              if (!res.ok) throw res;
              return res.json();
          })
          .then(data => {
              let existingRow = data.values?.[0] || [];

              let values;

              // Check if columns A and B are empty
              if (existingRow.length === 0 || existingRow[0] === "" || existingRow[1] === "") {
                  // If A and B are empty, initialize them with count and timestamp, and write the crew description in column N
                  values = [
                      [count.toString(), nowGMT, existingRow[2], existingRow[3], existingRow[4], existingRow[5], existingRow[6], selectedCondition]  // Initialize with count, timestamp, and entry
                  ];
              } else {
                  // If A and B are not empty, only update the entry in its column
                  values = [
                      [existingRow[0], existingRow[1], existingRow[2], existingRow[3], existingRow[4], existingRow[5], existingRow[6], selectedCondition]
                  ];
              }

              // Update the row in the sheet with the new values
              return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToWrite}?valueInputOption=RAW`, {
                  method: "PUT",
                  headers: {
                      "Authorization": `Bearer ${accessToken}`,
                      "Content-Type": "application/json"
                  },
                  body: JSON.stringify({ values })
              });
          })
          .then(response => response.json())
          .then(data => {
              console.log("Condition Written to Sheet...", data);
          })
          .catch(error => {
              console.error("Failed to write Condition:", error);
          });
      }
      //function for writing checkbox entry
      function writeCheckboxToSheet(labelText) {
        const targetRow = count + 1;
        const nowGMT = new Date().toISOString();  // Current time in GMT format
        const rangeToWrite = `Sheet1!A${targetRow}:N${targetRow}`;  // Write to column N of the target row
        const rangeToCheck = `Sheet1!A${targetRow}:B${targetRow}`;  // Check the first two columns (A,B)
        fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToCheck}?majorDimension=ROWS`, {
              method: "GET",
              headers: {
                  "Authorization": `Bearer ${accessToken}`,
              }
          })
          .then(res => {
              if (!res.ok) throw res;
              return res.json();
          })
          .then(data => {
              let existingRow = data.values?.[0] || [];

              let values;

              // Check if columns A and B are empty
              if (existingRow.length === 0 || existingRow[0] === "" || existingRow[1] === "") {
                  // If A and B are empty, initialize them with count and timestamp, and write the crew description in column N
                  values = [
                      [count.toString(), nowGMT, existingRow[2], existingRow[3], existingRow[4], existingRow[5], existingRow[6], existingRow[7], existingRow[8], existingRow[9] , existingRow[10], existingRow[11], existingRow[12], labelText]  // Initialize with count, timestamp, and entry
                  ];
              } else {
                  // If A and B are not empty, only update the entry in its column
                  values = [
                      [existingRow[0], existingRow[1], existingRow[2], existingRow[3], existingRow[4], existingRow[5], existingRow[6], existingRow[7], existingRow[8], existingRow[9] , existingRow[10], existingRow[11], existingRow[12], labelText]
                  ];
              }

              // Update the row in the sheet with the new values
              return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToWrite}?valueInputOption=RAW`, {
                  method: "PUT",
                  headers: {
                      "Authorization": `Bearer ${accessToken}`,
                      "Content-Type": "application/json"
                  },
                  body: JSON.stringify({ values })
              });
          })
          .then(response => response.json())
          .then(data => {
              console.log("Planned/Unplanned Updated:", data);
          })
          .catch(error => {
              console.error("Failed to write Planned/Unplanned:", error);
          });
      }
      //function for writing units to sheet
      function writeUnitsToSheet(selectedUnits) {
        const targetRow = count + 1;
        const nowGMT = new Date().toISOString();  // Current time in GMT format
        const rangeToWrite = `Sheet1!A${targetRow}:G${targetRow}`;  // Write to column G of the target row
        const rangeToCheck = `Sheet1!A${targetRow}:B${targetRow}`;  // Check the first two columns (A,B)
        fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToCheck}?majorDimension=ROWS`, {
              method: "GET",
              headers: {
                  "Authorization": `Bearer ${accessToken}`,
              }
          })
          .then(res => {
              if (!res.ok) throw res;
              return res.json();
          })
          .then(data => {
              let existingRow = data.values?.[0] || [];

              let values;

              // Check if columns A and B are empty
              if (existingRow.length === 0 || existingRow[0] === "" || existingRow[1] === "") {
                  // If A and B are empty, initialize them with count and timestamp, and write the crew description in column D
                  values = [
                      [count.toString(), nowGMT, existingRow[2], existingRow[3], existingRow[4], existingRow[5], selectedUnits]  // Initialize with count, timestamp, and entry
                  ];
              } else {
                  // If A and B are not empty, only update the entry in its column
                  values = [
                      [existingRow[0], existingRow[1], existingRow[2], existingRow[3], existingRow[4], existingRow[5], selectedUnits]
                  ];
              }

              // Update the row in the sheet with the new values
              return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToWrite}?valueInputOption=RAW`, {
                  method: "PUT",
                  headers: {
                      "Authorization": `Bearer ${accessToken}`,
                      "Content-Type": "application/json"
                  },
                  body: JSON.stringify({ values })
              });
          })
          .then(response => response.json())
          .then(data => {
              console.log("Units Written:", data);
          })
          .catch(error => {
              console.error("Failed to write Units:", error);
          });
      }
      //function for writing sample type to sheet
      function writeSampleTypeToSheet(selectedSampleType) {
        return new Promise((resolve, reject) => {
          const targetRow = count + 1;
          const nowGMT = new Date().toISOString();
          const rangeToWrite = `Sheet1!A${targetRow}:F${targetRow}`;
          const rangeToCheck = `Sheet1!A${targetRow}:B${targetRow}`;
  
          fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToCheck}?majorDimension=ROWS`, {
            method: "GET",
            headers: {
              "Authorization": `Bearer ${accessToken}`,
            },
          })
            .then(res => {
              if (!res.ok) throw res;
              return res.json();
            })
            .then(data => {
              let existingRow = data.values?.[0] || [];
              let values;
  
              if (existingRow.length === 0 || existingRow[0] === "" || existingRow[1] === "") {
                values = [
                  [count.toString(), nowGMT, existingRow[2], existingRow[3], existingRow[4], selectedSampleType],
                ];
              } else {
                values = [
                  [existingRow[0], existingRow[1], existingRow[2], existingRow[3], existingRow[4], selectedSampleType],
                ];
              }
  
              return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToWrite}?valueInputOption=RAW`, {
                method: "PUT",
                headers: {
                  "Authorization": `Bearer ${accessToken}`,
                  "Content-Type": "application/json",
                },
                body: JSON.stringify({ values }),
              });
            })
            .then(res => {
              if (!res.ok) throw res;
              return res.json();
            })
            .then(data => {
              console.log("Sample Type Written:", data);
              resolve(); // Resolve the Promise
            })
            .catch(err => {
              console.error("Failed to write Sample Type:", err);
              reject(err); // Reject the Promise
            });
        });
      }
      


      // function for writing the crew descrption to sheet
      function writeCrewDescriptionToSheet(crewDescription) {
          const targetRow = count + 1;  // This determines the row to write to
          const nowGMT = new Date().toISOString();  // Current time in GMT format
          const rangeToWrite = `Sheet1!E${targetRow}`;  // Write to column E of the target row
          const rangeToCheck = `Sheet1!A${targetRow}:E${targetRow}`;  // Check the first four columns (A-D)

          fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToCheck}?majorDimension=ROWS`, {
              method: "GET",
              headers: {
                  "Authorization": `Bearer ${accessToken}`,
              }
          })
          .then(res => {
              if (!res.ok) throw res;
              return res.json();
          })
          .then(data => {
              let existingRow = data.values?.[0] || [];

              let values;

              // Check if columns A and B are empty
              if (existingRow.length === 0 || existingRow[0] === "" || existingRow[1] === "") {
                  // If A and B are empty, initialize them with count and timestamp, and write the crew description in column E
                  values = [
                      [count.toString(), nowGMT, existingRow[2], existingRow[3], crewDescription]  // Initialize with count, timestamp, and description
                  ];
              } else {
                  // If A and B are not empty, only update the crew description in column D
                  values = [
                      [existingRow[0], existingRow[1], existingRow[2], existingRow[3], crewDescription]  // Keep existing values in A, B, C, and update D
                  ];
              }

              // Update the row in the sheet with the new values
              return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToCheck}?valueInputOption=RAW`, {
                  method: "PUT",
                  headers: {
                      "Authorization": `Bearer ${accessToken}`,
                      "Content-Type": "application/json"
                  },
                  body: JSON.stringify({ values })
              });
          })
          .then(response => response.json())
          .then(data => {
              console.log("Crew Description written:", data);
          })
          .catch(error => {
              console.error("Failed to write Crew Description:", error);
          });
      }

      // Function to fetch the pre-filled name for the current row
      function fetchNameForRow(rowIndex) {
      const range = `Sheet1!A${rowIndex + 2}:A${rowIndex + 2}`; // Adjusted to use rowIndex + 2 to account for headers

      return safeApiCall(() => {
        return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${range}?majorDimension=ROWS`, {
          method: "GET",
          headers: {
            "Authorization": `Bearer ${accessToken}`,
          },
        })
          .then((response) => {
            if (!response.ok) throw response;
            return response.json();
          })
          .then((data) => {
            const editableName = document.getElementById("editableName");
            const name = data.values?.[0]?.[0] || "Sample Name";

            if (editableName) {
              editableName.value = name;

              // Apply gray color if the placeholder is used
              if (name === "Sample Name") {
                editableName.style.color = "#b5b7b9"; // Gray color
              } else {
                editableName.style.color = "#24292e"; // Default text color
              }
            }

            return name;
          })
          .catch((error) => {
            console.error("Failed to fetch name:", error);
            return "Sample Name"; // Default name on error
          });
      });
    }

      let tokenClient;
      const CLIENT_ID = '263288053429-39j61v5mij7mhrtqg9peqov1i33nedc6.apps.googleusercontent.com';
      const SPREADSHEET_ID = '1efR88nP511yGEPgjsR9KcT0nE2TQImzuxyYYZ6uUKGo';
      let accessToken = localStorage.getItem('accessToken');
      let count = 1;
  
      const checkbox1 = document.getElementById('Planned');
      const checkbox2 = document.getElementById('Unplanned');
  
      checkbox1.addEventListener('change', () => { if (checkbox1.checked) checkbox2.checked = false; });
      checkbox2.addEventListener('change', () => { if (checkbox2.checked) checkbox1.checked = false; });
  
      function initTokenClient() {
        tokenClient = google.accounts.oauth2.initTokenClient({
          client_id: CLIENT_ID,
          scope: 'https://www.googleapis.com/auth/spreadsheets',
          callback: (tokenResponse) => {
            if (tokenResponse.access_token) {
              accessToken = tokenResponse.access_token;
              localStorage.setItem('accessToken', accessToken);
              console.log("Access token refreshed.");
            } else {
              console.error("Failed to refresh access token.");
            }
          }
        });
      }
  
      function refreshAccessToken(callback) {
        if (!tokenClient) {
          alert("Session expired. Please sign in again.");
          window.location.href = 'index.html'; // Redirect to your login page
          return;
        }

        tokenClient.callback = (tokenResponse) => {
          if (tokenResponse.access_token) {
            accessToken = tokenResponse.access_token;
            localStorage.setItem('accessToken', accessToken);
            console.log("Token refreshed.");
            if (callback) callback();
          } else {
            alert("Session expired. Please sign in again.");
            localStorage.removeItem('accessToken');
            window.location.href = 'index.html'; // Redirect to your login page
          }
        };

        tokenClient.requestAccessToken({ prompt: '' });
      }
    
    function safeApiCall(apiFunction) {
        if (!accessToken) {
          alert("Session expired. Please sign in again.");
          window.location.href = 'index.html'; // Redirect to your login page
          return Promise.reject("No access token"); // Return a rejected Promise
        }

        return apiFunction().catch(err => {
          if (err?.status === 401 || err?.message?.includes('401')) {
            console.warn("Access token expired. Attempting refresh...");
            return new Promise((resolve, reject) => {
              refreshAccessToken(() => {
                apiFunction().then(resolve).catch(reject); // Retry the API call
              });
            });
          } else {
            console.error("API error:", err);
            throw err; // Re-throw the error for further handling
          }
        });
      }
  
      function updateLabel() {
        const entryNumber = document.getElementById("entryNumber");
        const footerCount = document.getElementById("footerCount");

        if (entryNumber) {
          entryNumber.innerText = `Entry #${count}`;
          console.log("Label updated to:", entryNumber.innerText); // Debugging log
        } else {
          console.error("Entry number element not found.");
        }

        if (footerCount) {
          footerCount.innerText = `${count}`;
          console.log("Footer updated to:", footerCount.innerText); // Debugging log
        } else {
          console.error("Footer element not found.");
        }
      }

      function clearFields() {
        document.querySelectorAll('input[type="text"]').forEach(input => input.value = "");
        document.querySelectorAll('select').forEach(select => select.selectedIndex = 0);
        document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => checkbox.checked = false);
      }

      // Start Time Button Logic
      const startButton = document.querySelectorAll(".button-group-box .button")[0]; // First button in the first button-group-box
      startButton.addEventListener("click", () => {
        safeApiCall(writeStartTime);
      });

      // End Time Button Logic
      const endButton = document.querySelectorAll(".button-group-box .button")[1]; // Second button in the first button-group-box
      endButton.addEventListener("click", () => {
        safeApiCall(writeEndTime);
      });

      function writeStartTime() {
        return new Promise((resolve, reject) => {
          const nowGMT = new Date().toISOString();
          const targetRow = count + 1;
          const rangeToCheck = `Sheet1!A${targetRow}:C${targetRow}`;
  
          fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToCheck}?majorDimension=ROWS`, {
            method: "GET",
            headers: {
              "Authorization": `Bearer ${accessToken}`,
            }
          })
          .then(res => {
            if (!res.ok) throw res;
            return res.json();
          })
          .then(data => {
            let existingRow = data.values?.[0] || [];
            let values = (existingRow.length === 0 || existingRow.every(cell => cell === ""))
              ? [[count.toString(), nowGMT, nowGMT]]
              : [[existingRow[0], existingRow[1], nowGMT]];
  
            return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToCheck}?valueInputOption=RAW`, {
              method: "PUT",
              headers: {
                "Authorization": `Bearer ${accessToken}`,
                "Content-Type": "application/json"
              },
              body: JSON.stringify({ values })
            });
          })
          .then(res => {
            if (!res.ok) throw res;
            return res.json();
          })
          .then(data => {
            console.log("Start time written or updated:", data);
            startButton.classList.add("success");
            setTimeout(() => startButton.classList.remove("success"), 2000);
            resolve();
          })
          .catch(err => reject(err));
        });
      }
  
      function writeEndTime() {
        return new Promise((resolve, reject) => {
          const nowGMT = new Date().toISOString();
          const targetRow = count + 1;
          const rangeToCheck = `Sheet1!A${targetRow}:D${targetRow}`;
  
          fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToCheck}?majorDimension=ROWS`, {
            method: "GET",
            headers: {
              "Authorization": `Bearer ${accessToken}`,
            }
          })
          .then(res => {
            if (!res.ok) throw res;
            return res.json();
          })
          .then(data => {
            let existingRow = data.values?.[0] || [];
            let values = (existingRow.length === 0 || existingRow.every(cell => cell === ""))
              ? [[count.toString(), nowGMT, "", nowGMT]]
              : [[existingRow[0], existingRow[1], existingRow[2], nowGMT]];
  
            return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeToCheck}?valueInputOption=RAW`, {
              method: "PUT",
              headers: {
                "Authorization": `Bearer ${accessToken}`,
                "Content-Type": "application/json"
              },
              body: JSON.stringify({ values })
            });
          })
          .then(res => {
            if (!res.ok) throw res;
            return res.json();
          })
          .then(data => {
            console.log("End time written or updated:", data);
            endButton.classList.add("success");
            setTimeout(() => endButton.classList.remove("success"), 2000);
            resolve();
          })
          .catch(err => reject(err));
        });
      }
  
      function submitToSheet() {
        safeApiCall(() => {
          return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/Sheet1!A1:append?valueInputOption=RAW&insertDataOption=INSERT_ROWS`, {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${accessToken}`,
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ values: [[document.getElementById("dataInput")?.value || ""]] }),
          })
          .then(res => {
            if (!res.ok) throw res;
            return res.json();
          })
          .then(data => {
            alert("Data written to sheet!");
          });
        });
      }

      function insertRowBelow(targetRowIndex) {
        const sheetId = 0; // Replace with your sheet's ID (usually 0 for the first sheet)
        const insertRowIndex = targetRowIndex + 1; // Add 1 to insert below the target row

        const requestBody = {
          requests: [
            {
              insertDimension: {
                range: {
                  sheetId: sheetId,
                  dimension: "ROWS",
                  startIndex: insertRowIndex,
                  endIndex: insertRowIndex + 1, // Insert one row
                },
                inheritFromBefore: false, // Set to true if you want the new row to inherit formatting
              },
            },
          ],
        };

        fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}:batchUpdate`, {
          method: "POST",
          headers: {
            "Authorization": `Bearer ${accessToken}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify(requestBody),
        })
          .then((response) => {
            if (!response.ok) throw response;
            return response.json();
          })
          .then((data) => {
            console.log("Row inserted successfully:", data);

            // Increment count to reflect the new row
            count++;
            console.log("Count updated to:", count);

            // Update the label to reflect the new entry
            updateLabel();

            // Fetch and display the name for the new row
            fetchNameForRow(count - 1).then((name) => {
              const editableName = document.getElementById("editableName");
              const entryNumber = document.getElementById("entryNumber");

              if (editableName) {
                editableName.value = name;
                console.log("Editable name updated to:", name);
              }

              if (entryNumber) {
                entryNumber.innerText = `Entry #${count}`;
                console.log("Entry number updated to:", entryNumber.innerText);
              }
            });
          })
          .catch((error) => {
            console.error("Failed to insert row:", error);
          });
      }


      // Function to write the updated name to the spreadsheet
      function writeNameToSheet(rowIndex, name) {
        const range = `Sheet1!A${rowIndex + 2}:A${rowIndex + 2}`; // Adjusted to use rowIndex + 2 to account for headers
        const values = [[name]];

        return fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${range}?valueInputOption=RAW`, {
          method: "PUT",
          headers: {
            "Authorization": `Bearer ${accessToken}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ values }),
        })
          .then((response) => {
            if (!response.ok) throw response;
            return response.json();
          })
          .then((data) => {
            console.log("Name updated successfully:", data);
          })
          .catch((error) => {
            console.error("Failed to update name:", error);
          });
      }

      // Initialize the editable name and entry number
      function initializeNameAndEntry() {
        const editableName = document.getElementById("editableName");
        const entryNumber = document.getElementById("entryNumber");

        // Fetch and display the name for the current row
        fetchNameForRow(count - 1).then((name) => {
          editableName.value = name;

          // Apply gray color if the placeholder is used
          if (name === "Sample Name") {
            editableName.style.color = "#8e9296"; // Gray color for placeholder
          } else {
            editableName.style.color = "#24292e"; // Default text color
          }
        });

        // Update the entry number
        entryNumber.innerText = `Entry #${count}`;

        // Add event listener for editing the name
        editableName.addEventListener("keydown", (event) => {
          if (event.key === "Enter" || event.keyCode === 13) {
            const updatedName = editableName.value.trim();
            if (updatedName) {
              writeNameToSheet(count - 1, updatedName).then(() => {
                // Apply the "saved" style
                editableName.classList.add("saved");
                editableName.style.color = "#0969da"; // Set color to blue when saved
                setTimeout(() => {
                  editableName.classList.remove("saved");
                  editableName.style.color = "#24292e"; // Reset to default text color
                }, 2000); // Remove the style after 2 seconds
              });
            }
          }
        });
      }
     // Update the name and entry number when navigating between rows
      function updateNameAndEntry() {
        const editableName = document.getElementById("editableName");
        const entryNumber = document.getElementById("entryNumber");

        // Fetch and display the name for the current row
        fetchNameForRow(count - 1).then((name) => {
          editableName.value = name;
        });

        // Update the entry number
        entryNumber.innerText = `Entry #${count}`;
      }

  
      window.onload = () => {
        if (!localStorage.getItem('accessToken')) {
          alert("Session expired. Please sign in again.");
          window.location.href = 'index.html'; // Redirect to your login page
          return;
        }

        initTokenClient();
        updateLabel();
        initializeNameAndEntry();

        // Update name and entry number when navigating rows
        document.querySelectorAll(".button-group-box")[1].querySelector("button:first-child").addEventListener("click", () => {
          if (count > 1) {
            count--;
            updateLabel();
            updateNameAndEntry();
            clearFields();
          }
        });

        document.querySelectorAll(".button-group-box")[1].querySelector("button:nth-child(2)").addEventListener("click", () => {
          count++;
          updateLabel();
          updateNameAndEntry();
          clearFields();
        });
        //event listener logic
         // Add the event listener to detect when the Return key is pressed in the Crew Description field
         document.getElementById("CrewDescription").addEventListener("keydown", function(event) {
          const key = event.key || event.keyCode || event.which;

          // Check for Enter key (keyCode 13)
          if (key === "Enter" || key === 13) {
            const crewDescription = event.target.value;
            if (crewDescription.trim()) {
              writeCrewDescriptionToSheet(crewDescription);
              event.target.value = "";
            }
          }
        });
        

        //listener logic for sample type dropdown
        document.getElementById("SampleType").addEventListener("change", function (event) {
          const selectedSampleType = event.target.value;

          // Call the function and reset the dropdown after the promise resolves
          safeApiCall(() => writeSampleTypeToSheet(selectedSampleType))
            .then(() => {
              console.log("Sample type written successfully.");
              event.target.selectedIndex = 0; // Reset to the first option
            })
            .catch(err => {
              console.error("Error writing sample type:", err);
            });
        });

        // Add the event listener to detect when the Return key is pressed in the Units field
        document.getElementById("Units").addEventListener("keydown", function(event) {
          const key = event.key || event.keyCode || event.which;

          // Check for Enter key (keyCode 13)
          if (key === "Enter" || key === 13) {
            const selectedUnits = event.target.value;
            if (selectedUnits.trim()) {
              writeUnitsToSheet(selectedUnits);
              event.target.value = "";
            }
          }
        });
        //listener logic for checkbox entries
        // Select all checkboxes inside label elements
        const checkboxes = document.querySelectorAll('input[type="checkbox"]');

        checkboxes.forEach(checkbox => {
            checkbox.addEventListener("change", function(event) {
                if (event.target.checked) {
                    // Get the label text (parentElement is the <label>)
                    const labelText = event.target.parentElement.textContent.trim();
                    console.log("Checked:", labelText);
                    

                    // call function for checkbox write
                    writeCheckboxToSheet(labelText)
                    
                }
            });
        });

        //listener logic for condition dropdown
        document.getElementById("Condition").addEventListener("change",function(event) {
          const selectedCondition = event.target.value;

          //CALL FUNCTION HERE WITH THE INPUT ABOVE!!!
          writeConditionToSheet(selectedCondition);
          event.target.value = "";
        });
        // Add the event listener to detect when the Return key is pressed in the Mass Estimate field
        document.getElementById("MassEstimate").addEventListener("keydown", function(event) {
          const key = event.key || event.keyCode || event.which;

          // Check for Enter key (keyCode 13)
          if (key === "Enter" || key === 13) {
            const selectedMass = event.target.value;
            if (selectedMass.trim()) {
              writeMassToSheet(selectedMass);
              event.target.value = "";
            }
          }
        });
        // Add the event listener to detect when the Return key is pressed in the Volume Estimate field
        document.getElementById("VolumeEstimate").addEventListener("keydown", function(event) {
          const key = event.key || event.keyCode || event.which;

          // Check for Enter key (keyCode 13)
          if (key === "Enter" || key === 13) {
            const selectedVolume = event.target.value;
            if (selectedVolume.trim()) {
              writeVolumeToSheet(selectedVolume);
              event.target.value = "";
            }
          }
        });
        // Add the event listener to detect when the Return key is pressed in the Container Number(s) field
        document.getElementById("ContainerNumber").addEventListener("keydown", function(event) {
          const key = event.key || event.keyCode || event.which;

          // Check for Enter key (keyCode 13)
          if (key === "Enter" || key === 13) {
            const selectedContainer = event.target.value;
            if (selectedContainer.trim()) {
              writeContainerToSheet(selectedContainer);
              event.target.value = "";
            }
          }
        });
        // Add the event listener to detect when the Return key is pressed in the Contamination Notes field
        document.getElementById("ContaminationNotes").addEventListener("keydown", function(event) {
          const key = event.key || event.keyCode || event.which;

          // Check for Enter key (keyCode 13)
          if (key === "Enter" || key === 13) {
            const selectedContamination = event.target.value;
            if (selectedContamination.trim()) {
              writeContaminationToSheet(selectedContamination);
              event.target.value = "";
            }
          }
        });

        // Add the event listener to detect when the Return key is pressed in the Units field
        document.getElementById("SamplingTools").addEventListener("keydown", function(event) {
          const key = event.key || event.keyCode || event.which;

          // Check for Enter key (keyCode 13)
          if (key === "Enter" || key === 13) {
            const selectedTools = event.target.value;
            if (selectedTools.trim()) {
              writeToolsToSheet(selectedTools);
              event.target.value = "";
            }
          }
        });
        document.getElementById("addRowButton").addEventListener("click", () => {
          console.log(`Inserting a new row below Entry #${count}`);
          insertRowBelow(count); // Use the current count as the input argument
        });
        
      };
    </script>
  </body>
  </html>